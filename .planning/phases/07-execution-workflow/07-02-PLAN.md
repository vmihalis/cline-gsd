---
phase: 07-execution-workflow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - workflows/gsd/gsd-execute-phase.md
autonomous: true

must_haves:
  truths:
    - "/gsd-execute-phase N discovers incomplete plans and executes them in wave order"
    - "Execution happens in main Cline context (workflow guides Cline through tasks inline)"
    - "Each completed task is committed atomically with conventional commit format"
    - "SUMMARY.md is generated after each plan completes"
    - "STATE.md and ROADMAP.md are updated after each plan completes"
    - "Interrupted execution can be resumed (completed plans are skipped)"
    - "Checkpoint tasks pause for user interaction when encountered"
    - "Yolo mode auto-continues between plans; interactive mode pauses"
  artifacts:
    - path: "workflows/gsd/gsd-execute-phase.md"
      provides: "Cline workflow for /gsd-execute-phase command with main-context execution"
      min_lines: 200
  key_links:
    - from: "workflows/gsd/gsd-execute-phase.md"
      to: "src/execute-phase.js"
      via: "node -e import"
      pattern: "import.*execute-phase"
    - from: "workflows/gsd/gsd-execute-phase.md"
      to: "src/state-read.js"
      via: "node -e import"
      pattern: "import.*state-read"
    - from: "workflows/gsd/gsd-execute-phase.md"
      to: "src/discuss-phase.js"
      via: "node -e import for getPhaseDetails"
      pattern: "import.*discuss-phase"
---

<objective>
Create the Cline workflow file for `/gsd-execute-phase N` that orchestrates main-context plan execution with atomic commits, SUMMARY.md generation, and state updates.

Purpose: This is the execution engine for Cline-GSD. Unlike upstream GSD which spawns subagents via the Task tool, Cline-GSD executes plans directly in the main conversation context. The workflow reads PLAN.md files, presents task instructions to Cline, guides atomic commits per task, generates SUMMARY.md after each plan, and updates STATE.md/ROADMAP.md. This adapts the upstream execute-phase.md and execute-plan.md patterns for single-context execution.

Output: `workflows/gsd/gsd-execute-phase.md` workflow file.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/workflows/execute-phase.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
@/Users/memehalis/.claude/get-shit-done/references/git-integration.md
@/Users/memehalis/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-execution-workflow/07-RESEARCH.md
@workflows/gsd/gsd-plan-phase.md
@workflows/gsd/gsd-map-codebase.md
@src/execute-phase.js
@src/state-read.js
@src/state-write.js
@src/discuss-phase.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workflows/gsd/gsd-execute-phase.md workflow</name>
  <files>workflows/gsd/gsd-execute-phase.md</files>
  <action>
Create `workflows/gsd/gsd-execute-phase.md` following the established workflow patterns from `gsd-plan-phase.md` and `gsd-map-codebase.md`, adapted for main-context execution per the research findings.

Frontmatter:
```yaml
---
description: Execute plans for a phase with atomic commits per task and SUMMARY generation
---
```

Title: `# /gsd-execute-phase â€” Execute a Phase`

Opening paragraph: This workflow executes all plans in a phase sequentially in the main Cline context. For each plan, it reads the PLAN.md, executes each task inline (with Cline performing the actual code changes), commits each task atomically, generates SUMMARY.md, and updates STATE.md and ROADMAP.md. Plans execute in wave order. Completed plans (those with matching SUMMARY.md files) are skipped, enabling safe resumption after interruptions.

**Step 1: Parse phase number and load state**
- Extract phase number from user input. If not provided, read STATE.md for current phase or ask the user.
- Load project state:
```bash
node -e "
import { readPlanningConfig } from './src/state-read.js';
import { getPhaseDetails } from './src/discuss-phase.js';
const config = await readPlanningConfig('.planning');
const phase = await getPhaseDetails('.planning', PHASE_NUM);
console.log(JSON.stringify({ config: config.data, phase: phase.data }, null, 2));
"
```
- Load commit_docs config: `COMMIT_PLANNING_DOCS` from config.json (default true). Also check `git check-ignore -q .planning 2>/dev/null` to auto-detect gitignored.
- Load mode config: `mode` from config.json (yolo or interactive).
- If phase not found, stop with error.

**Step 2: Discover plans and check progress**
```bash
node -e "
import { discoverPlans, groupByWave } from './src/execute-phase.js';
const result = await discoverPlans('PHASE_DIR_PATH');
if (!result.success) { console.error(result.error); process.exit(1); }
const grouped = groupByWave(result.data.incomplete);
console.log(JSON.stringify({
  total: result.data.plans.length,
  completed: result.data.completed.length,
  incomplete: result.data.incomplete.length,
  waves: grouped.data.waveOrder,
  plans: result.data.plans.map(p => ({ id: p.id, wave: p.wave, complete: p.isComplete, autonomous: p.autonomous }))
}, null, 2));
"
```

Report discovery results:
- "Found N plans in phase (M completed, K remaining)"
- If all plans complete: "Phase already complete. Nothing to execute." and stop.
- Show wave structure table: Wave | Plans | Autonomous

**Step 3: Present execution plan**
Show the user what will happen:
```
## Execution Plan

**Phase {N}: {Name}** -- {K} plans remaining across {W} waves

| Wave | Plans | What it builds |
|------|-------|----------------|
| 1 | 07-01, 07-02 | {from plan objectives} |
| 2 | 07-03 | {from plan objectives} |
```

For each incomplete plan, skim the `<objective>` section to populate "What it builds" (3-8 words).

In yolo mode: auto-continue. In interactive mode: ask "Proceed with execution?"

**Step 4: Execute plans (main loop)**
For each wave (in ascending order), for each plan in the wave:

**4a. Read the plan:**
```bash
cat .planning/phases/XX-name/{phase}-{plan}-PLAN.md
```

**4b. Record start time:**
Note the start time for duration tracking.

**4c. Load execution context:**
Read the `<context>` section file references. Read each referenced file to have full context available.

**4d. Execute each task in order:**
For each `<task>` in the plan's `<tasks>` section:

- **If type="auto":**
  1. Read the `<action>` section carefully -- this IS the implementation instructions
  2. Execute the work described in `<action>` (create files, modify code, run commands)
  3. Apply deviation rules automatically:
     - Rule 1 (auto-fix bugs): Fix immediately, track
     - Rule 2 (auto-add missing critical): Add immediately, track
     - Rule 3 (auto-fix blocking issues): Fix to unblock, track
     - Rule 4 (architectural changes): STOP and ask user
  4. Run the `<verify>` check to confirm task is complete
  5. Confirm `<done>` criteria are met
  6. **Atomic task commit:**
     - Run `git status --short` to identify changed files
     - Stage ONLY the files from this task individually (`git add path/to/file`)
     - NEVER use `git add .`, `git add -A`, or `git add -u`
     - Determine commit type (feat, fix, test, refactor, chore, docs, style, perf)
     - Build commit message using: `node -e "import { buildTaskCommitMessage } from './src/execute-phase.js'; console.log(buildTaskCommitMessage('TYPE', 'PLAN_ID', 'description', ['detail1', 'detail2']));"` or construct it directly following `{type}({planId}): {description}` format
     - Commit: `git commit -m "MESSAGE"`
     - Record commit hash: `git rev-parse --short HEAD`
  7. Track: task name, commit hash, commit type, files modified

- **If type="checkpoint:human-verify":**
  1. Present what was built (from `<what-built>`)
  2. Show verification steps (from `<how-to-verify>`)
  3. STOP and wait for user response
  4. If "approved": continue to next task
  5. If issues described: address them, then re-verify

- **If type="checkpoint:decision":**
  1. Present decision and options
  2. STOP and wait for user selection
  3. Record decision for SUMMARY
  4. Continue with user's choice

- **If type="checkpoint:human-action":**
  1. Show what Claude already automated
  2. Present the unavoidable manual step
  3. STOP and wait for user to complete
  4. Verify if possible, then continue

**4e. Handle authentication gates:**
If any CLI/API command returns an auth error during task execution:
1. Recognize it as an auth gate (not a bug)
2. Create a dynamic checkpoint -- present auth steps to user
3. Wait for user to authenticate
4. Retry the original command
5. Continue normally

**4f. Generate SUMMARY.md:**
After all tasks in a plan complete:
1. Calculate duration from start time
2. Collect all task commit records, accomplishments, deviations, decisions
3. Generate SUMMARY.md content using:
```bash
node -e "
import { buildSummaryContent } from './src/execute-phase.js';
const content = buildSummaryContent({
  phase: 'PHASE_ID', plan: 'PLAN_NUM', title: 'PLAN_TITLE',
  oneLiner: 'SUBSTANTIVE_ONE_LINER',
  subsystem: 'SUBSYSTEM', tags: [TAGS],
  requires: [REQUIRES], provides: [PROVIDES], affects: [AFFECTS],
  techAdded: [TECH], patterns: [PATTERNS],
  filesCreated: [FILES_CREATED], filesModified: [FILES_MODIFIED],
  decisions: [DECISIONS], duration: 'DURATION', completed: 'TODAY_DATE',
  tasks: [TASK_RECORDS], accomplishments: [ACCOMPLISHMENTS],
  deviations: 'DEVIATION_TEXT', issues: 'ISSUES_TEXT',
  nextReadiness: 'NEXT_READINESS'
});
console.log(content);
"
```
4. Write SUMMARY.md to `.planning/phases/XX-name/{phase}-{plan}-SUMMARY.md`
5. Self-check: verify first 2 created files exist on disk, check `git log --oneline --grep="{planId}"` returns commits

**4g. Update state:**
```bash
node -e "
import { updateStateAfterPlan } from './src/execute-phase.js';
const result = await updateStateAfterPlan('.planning', PHASE_NUM, PLAN_NUM, 'PHASE_NAME', TOTAL_PLANS, COMPLETED_SO_FAR);
console.log(JSON.stringify(result, null, 2));
"
```

**4h. Commit metadata:**
If COMMIT_PLANNING_DOCS is true:
```bash
git add .planning/phases/XX-name/{phase}-{plan}-SUMMARY.md .planning/STATE.md .planning/ROADMAP.md
```
Build metadata commit message using:
```bash
node -e "
import { buildPlanCommitMessage } from './src/execute-phase.js';
console.log(buildPlanCommitMessage('PLAN_ID', 'PLAN_NAME', [TASK_NAMES], 'SUMMARY_PATH'));
"
```
Then: `git commit -m "MESSAGE"`

**4i. Report plan completion:**
```
Plan {planId} complete.
Summary: .planning/phases/XX-name/{phase}-{plan}-SUMMARY.md
{M} of {N} plans complete for Phase {X}.
```

**4j. Inter-plan routing:**
- In yolo mode: auto-continue to next plan
- In interactive mode: ask user "Continue to next plan?" or suggest `/clear` for fresh context
- If context usage is getting high (approaching 50%+): suggest `/clear` and re-running `/gsd-execute-phase N` to resume with fresh context

**Step 5: Handle failures**
If any task fails:
- Report which task failed and why
- Offer options: Retry, Skip (mark incomplete in SUMMARY), Stop
- If stopped: generate partial SUMMARY.md noting incomplete tasks
- STATE.md updated with last completed position

**Step 6: Phase completion**
After all plans complete:
```bash
node -e "
import { getPhaseCompletionStatus } from './src/execute-phase.js';
const status = await getPhaseCompletionStatus('PHASE_DIR');
console.log(JSON.stringify(status, null, 2));
"
```

If all plans complete:
```
## Phase {N}: {Name} Complete

All {M} plans finished.

---

## Next Up

**Phase {N+1}: {Next Name}** -- {Goal from ROADMAP.md}

`/gsd-plan-phase {N+1}`

<sub>`/clear` first -- fresh context window</sub>

---

**Also available:**
- `/gsd-progress` -- see updated project status
```

If more phases and all complete (milestone done), celebrate and suggest `/gsd-progress`.

**Behavioral Guidelines:**
- Execution is main-context. Cline reads task instructions and performs them inline. No subagents.
- Atomic commits: one commit per task, never batch. Stage files individually.
- Deviation rules are automatic (Rules 1-3) except architectural changes (Rule 4 asks user).
- Context management: if a plan is consuming too much context, finish it and suggest `/clear` before the next plan.
- Never skip the SUMMARY.md generation -- it's the completion signal for resumption.
- Parallelization config is ignored for execution (main context is inherently sequential). It only applies to research/mapping agents.
- The `autonomous` flag is informational in main context. All execution is interactive. Use it to warn the user: "This plan has checkpoints that will require your input."
- Keep orchestration output concise. The PLAN.md itself is the prompt.
- Record commit hashes for every task -- they go into SUMMARY.md.
  </action>
  <verify>
Verify the file exists and has correct structure:
- `head -5 workflows/gsd/gsd-execute-phase.md` should show YAML frontmatter
- `grep -c "^## Step" workflows/gsd/gsd-execute-phase.md` or `grep -c "^\*\*Step" workflows/gsd/gsd-execute-phase.md` should return 6 (six steps)
- `grep "execute-phase.js" workflows/gsd/gsd-execute-phase.md` should show references to the helper module
- `grep "buildTaskCommitMessage\|buildPlanCommitMessage\|buildSummaryContent\|discoverPlans\|groupByWave\|updateStateAfterPlan\|getPhaseCompletionStatus" workflows/gsd/gsd-execute-phase.md` should show all 7 helper function references
  </verify>
  <done>
Workflow file exists at `workflows/gsd/gsd-execute-phase.md` with YAML frontmatter, 6 steps (parse/load, discover, present plan, execute loop, handle failures, phase completion), and behavioral guidelines. Adapts upstream execute-phase.md + execute-plan.md for main-context execution. References all 7 exports from src/execute-phase.js. Covers: wave-based ordering, atomic task commits, SUMMARY generation, state updates, checkpoint handling, deviation rules, yolo/interactive mode, resumption via SUMMARY detection, and context management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify workflow references and completeness</name>
  <files>workflows/gsd/gsd-execute-phase.md</files>
  <action>
After creating the workflow, verify it covers all requirements:

1. **CMD-03 check:** Workflow is invocable as `/gsd-execute-phase N` -- confirm the title matches this pattern.

2. **EXEC-01 check:** Confirm no references to `spawnAgent`, `agent-spawn.js`, `cline "prompt" &`, or Task tool spawning. Execution must be main-context only.

3. **EXEC-02 check:** Confirm plans execute in wave order (wave 1 before wave 2). Within a wave, plans execute sequentially (not parallel).

4. **EXEC-03 check:** Confirm each task has an atomic commit step with `git add` (individual files) and `git commit`.

5. **EXEC-04 check:** Confirm SUMMARY.md is generated after each plan via `buildSummaryContent`.

6. **STATE-03 check:** Confirm atomic git commits per completed task (not per plan or per file batch).

7. **Resumption check:** Confirm completed plans are detected via SUMMARY.md and skipped.

8. **Checkpoint check:** Confirm checkpoint:human-verify, checkpoint:decision, and checkpoint:human-action are all handled.

If any check fails, update the workflow to address the gap.
  </action>
  <verify>
All 8 checks pass. The workflow covers all Phase 7 requirements without any gaps.
  </verify>
  <done>
Workflow verified against all Phase 7 requirements: CMD-03 (command name), EXEC-01 (main context only), EXEC-02 (wave ordering), EXEC-03 (atomic task commits), EXEC-04 (SUMMARY generation), STATE-03 (per-task commits), resumption (SUMMARY detection), and checkpoint handling (all 3 types).
  </done>
</task>

</tasks>

<verification>
1. `workflows/gsd/gsd-execute-phase.md` exists with YAML frontmatter and 6 steps
2. References all 7 exports from `src/execute-phase.js`
3. No references to agent spawning (spawnAgent, agent-spawn.js)
4. Covers atomic task commits with individual `git add` (not `git add .`)
5. SUMMARY.md generation uses `buildSummaryContent` from helper module
6. State updates use `updateStateAfterPlan` from helper module
7. Completed plans detected via SUMMARY.md matching (resumption support)
8. All 3 checkpoint types handled (human-verify, decision, human-action)
9. Yolo mode auto-continues; interactive mode pauses between plans
10. Deviation rules documented (Rules 1-4 from upstream execute-plan.md)
</verification>

<success_criteria>
- `workflows/gsd/gsd-execute-phase.md` is a complete Cline workflow with 6 steps
- Main-context execution only (no subagent references)
- Atomic task commits enforced (per task, individual file staging)
- SUMMARY.md generated after each plan completion
- STATE.md and ROADMAP.md updated after each plan
- All Phase 7 requirements (CMD-03, EXEC-01 through EXEC-04, STATE-03) addressed
- Resumption support via SUMMARY.md detection
- Checkpoint protocol for all 3 checkpoint types
</success_criteria>

<output>
After completion, create `.planning/phases/07-execution-workflow/07-02-SUMMARY.md`
</output>
