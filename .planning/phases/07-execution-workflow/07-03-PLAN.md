---
phase: 07-execution-workflow
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - scripts/test-execute-phase.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "Integration test validates discoverPlans finds PLAN.md files and detects SUMMARY.md completion"
    - "Integration test validates groupByWave correctly groups plans by wave number"
    - "Integration test validates buildTaskCommitMessage produces conventional commit format"
    - "Integration test validates buildPlanCommitMessage includes task list and SUMMARY path"
    - "Integration test validates buildSummaryContent generates YAML frontmatter and markdown body"
    - "Integration test validates getPhaseCompletionStatus detects complete vs incomplete phases"
    - "Integration test validates updateStateAfterPlan updates checkbox, progress, and position"
    - "package.json has test:execute-phase script"
  artifacts:
    - path: "scripts/test-execute-phase.js"
      provides: "Integration test for execute-phase.js module"
      min_lines: 150
    - path: "package.json"
      provides: "test:execute-phase script entry"
      contains: "test:execute-phase"
  key_links:
    - from: "scripts/test-execute-phase.js"
      to: "src/execute-phase.js"
      via: "import"
      pattern: "import.*execute-phase"
    - from: "scripts/test-execute-phase.js"
      to: "src/state-init.js"
      via: "import for ensurePhaseDir"
      pattern: "import.*state-init"
---

<objective>
Create integration tests for the execute-phase module and add the test script to package.json.

Purpose: Tests verify plan discovery, wave grouping, commit message formatting, SUMMARY.md template generation, state update orchestration, and phase completion detection. This catches path mismatches, frontmatter parsing issues, template errors, and state update regressions before real execution. Following the established test pattern from Phase 6 (test-plan-phase.js) and Phase 5 (test-map-codebase.js).

Output: `scripts/test-execute-phase.js` integration test and updated `package.json`.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-execution-workflow/07-01-SUMMARY.md
@scripts/test-plan-phase.js
@scripts/test-map-codebase.js
@src/execute-phase.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/test-execute-phase.js integration test</name>
  <files>scripts/test-execute-phase.js</files>
  <action>
Create `scripts/test-execute-phase.js` following the EXACT test pattern from `scripts/test-plan-phase.js`:
- Shebang: `#!/usr/bin/env node`
- Module-level doc comment with description, run command, and npm script
- tmpdir isolation with cleanup in `finally` block
- `assert/strict` for assertions
- `test(name, fn)` helper with pass/fail tracking
- Summary at end with `process.exit(failed > 0 ? 1 : 0)`

Imports:
```javascript
import assert from 'node:assert/strict';
import { mkdtemp, mkdir, writeFile, rm } from 'node:fs/promises';
import path from 'node:path';
import os from 'node:os';
import {
  discoverPlans, groupByWave, buildTaskCommitMessage,
  buildPlanCommitMessage, buildSummaryContent,
  getPhaseCompletionStatus
} from '../src/execute-phase.js';
```

Note: Do NOT test `updateStateAfterPlan` directly -- it calls `updateRoadmapProgress`, `updatePlanCheckbox`, and `updateStatePosition` which require real STATE.md/ROADMAP.md files with specific format. Those functions are already tested in test-state.js. Testing the orchestration wrapper would be integration-level and fragile. Instead, test all the other 6 functions that can be tested in isolation.

Test categories:

**--- Plan Discovery tests ---**

Test 1: `discoverPlans finds plans and detects completion`
- Create temp phase dir with 3 mock PLAN.md files (07-01-PLAN.md, 07-02-PLAN.md, 07-03-PLAN.md)
- Each PLAN.md has minimal valid frontmatter: `---\nphase: 07-test\nplan: 01\nwave: 1\nautonomous: true\ndepends_on: []\nfiles_modified: []\n---\n`
- Create one SUMMARY.md (07-01-SUMMARY.md) to simulate completion
- Call `discoverPlans(tempPhaseDir)`
- Assert `success: true`
- Assert `data.plans.length === 3`
- Assert `data.completed.length === 1` and `data.completed[0].id === '07-01'`
- Assert `data.incomplete.length === 2`

Test 2: `discoverPlans returns error for non-existent directory`
- Call `discoverPlans('/tmp/nonexistent-dir-12345')`
- Assert `success: false`
- Assert error message contains relevant information

Test 3: `discoverPlans returns empty arrays for directory with no plans`
- Create empty temp dir
- Call `discoverPlans(emptyDir)`
- Assert `success: true`
- Assert `data.plans.length === 0` and `data.completed.length === 0` and `data.incomplete.length === 0`

**--- Wave Grouping tests ---**

Test 4: `groupByWave groups plans correctly`
- Create mock plan array: [{id:'01', wave:1}, {id:'02', wave:1}, {id:'03', wave:2}, {id:'04', wave:3}]
- Call `groupByWave(mockPlans)`
- Assert `success: true`
- Assert `data.waveOrder` is `[1, 2, 3]`
- Assert wave 1 has 2 plans, wave 2 has 1 plan, wave 3 has 1 plan

Test 5: `groupByWave handles empty array`
- Call `groupByWave([])`
- Assert `success: true`
- Assert `data.waveOrder.length === 0`

**--- Commit Message tests ---**

Test 6: `buildTaskCommitMessage produces correct format`
- Call `buildTaskCommitMessage('feat', '07-01', 'create execute module')`
- Assert result equals `'feat(07-01): create execute module'`
- Call with details: `buildTaskCommitMessage('feat', '07-01', 'create module', ['discovery', 'grouping'])`
- Assert result contains `'- discovery'` and `'- grouping'`

Test 7: `buildPlanCommitMessage includes task list and summary path`
- Call `buildPlanCommitMessage('07-01', 'Execute-phase module', ['Task 1', 'Task 2'], '.planning/phases/07-test/07-01-SUMMARY.md')`
- Assert result starts with `'docs(07-01): complete Execute-phase module'`
- Assert result contains `'Tasks completed: 2/2'`
- Assert result contains `'- Task 1'` and `'- Task 2'`
- Assert result contains `'SUMMARY:'`

**--- SUMMARY Template tests ---**

Test 8: `buildSummaryContent generates valid frontmatter and sections`
- Call `buildSummaryContent({...})` with full data object (use realistic test values)
- Assert result starts with `'---'` (frontmatter delimiter)
- Assert result contains `'phase: 07-test'`
- Assert result contains `'## Accomplishments'`
- Assert result contains `'## Task Commits'`
- Assert result contains `'## Files Created'` or `'## Files Created/Modified'`
- Assert result contains `'## Decisions Made'`
- Assert result contains `'## Deviations from Plan'`
- Assert result contains `'## Next Phase Readiness'`

Test 9: `buildSummaryContent one-liner is substantive`
- Call with `oneLiner: 'Execute-phase module with 7 exports for plan discovery and commit helpers'`
- Assert result contains that exact one-liner string

**--- Phase Completion tests ---**

Test 10: `getPhaseCompletionStatus detects incomplete phase`
- Use the same temp dir from Test 1 (3 plans, 1 summary)
- Call `getPhaseCompletionStatus(tempPhaseDir)`
- Assert `success: true`
- Assert `data.allComplete === false`
- Assert `data.totalPlans === 3`
- Assert `data.completedPlans === 1`
- Assert `data.incompletePlans` contains `'07-02'` and `'07-03'`

Test 11: `getPhaseCompletionStatus detects complete phase`
- Create temp dir with 2 PLAN.md and 2 matching SUMMARY.md
- Call `getPhaseCompletionStatus(completeDir)`
- Assert `data.allComplete === true`

Test 12: `getPhaseCompletionStatus returns error for non-existent directory`
- Call `getPhaseCompletionStatus('/tmp/nonexistent-dir-12345')`
- Assert `success: false`

**Cleanup:** Remove temp directories in `finally` block.

Important: Do NOT test `updateStateAfterPlan` directly -- it chains multiple state-write.js functions that need a full STATE.md + ROADMAP.md setup. Those underlying functions are already covered by test-state.js. This matches the pattern from Phase 6 where `runPlanningPipeline` was excluded from testing.
  </action>
  <verify>
Run: `node scripts/test-execute-phase.js` -- should print all tests passing (12/12) and exit with code 0.
  </verify>
  <done>
Integration test passes 12/12 tests covering: plan discovery with completion detection, empty/error directory handling, wave grouping (including empty), commit message formatting (task and plan types), SUMMARY.md template structure (frontmatter + all required sections), one-liner inclusion, phase completion detection (incomplete and complete), and error handling. Test follows established tmpdir isolation pattern from test-plan-phase.js.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test:execute-phase script to package.json</name>
  <files>package.json</files>
  <action>
Read the current `package.json` and add a new script entry:
```json
"test:execute-phase": "node scripts/test-execute-phase.js"
```

Add it after the existing `test:agents` entry (maintaining alphabetical ordering within the scripts section). The scripts section should look like:
```json
"scripts": {
  "test:agents": "node scripts/test-agent-infra.js",
  "test:execute-phase": "node scripts/test-execute-phase.js",
  "test:map-codebase": "node scripts/test-map-codebase.js",
  "test:plan-phase": "node scripts/test-plan-phase.js",
  "test:project-init": "node scripts/test-project-init.js",
  "test:state": "node scripts/test-state.js"
}
```

Do NOT modify any other fields in package.json.

After updating package.json, run the test to verify:
```bash
npm run test:execute-phase
```
  </action>
  <verify>
Run: `npm run test:execute-phase` -- should execute the test script and pass all tests.
Also verify: `node -e "import pkg from './package.json' with { type: 'json' }; console.log(pkg.default.scripts['test:execute-phase'] ? 'PASS' : 'FAIL');"` -- should print PASS.
  </verify>
  <done>
`package.json` has `test:execute-phase` script in alphabetical order. `npm run test:execute-phase` executes successfully with all 12 tests passing.
  </done>
</task>

</tasks>

<verification>
1. `node scripts/test-execute-phase.js` passes all 12 tests (exit code 0)
2. `npm run test:execute-phase` runs successfully
3. Tests cover: plan discovery, wave grouping, commit messages, SUMMARY template, phase completion
4. No test calls updateStateAfterPlan (avoids fragile state file setup)
5. Tests use tmpdir isolation with cleanup in finally block
6. Test pattern matches existing test-plan-phase.js structure
</verification>

<success_criteria>
- 12 integration tests passing in `scripts/test-execute-phase.js`
- Tests catch key pitfalls: path mismatches, frontmatter parsing, template structure, completion detection
- `package.json` has `test:execute-phase` script entry in alphabetical order
- `npm run test:execute-phase` exits cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-execution-workflow/07-03-SUMMARY.md`
</output>
