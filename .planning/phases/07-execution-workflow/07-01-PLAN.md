---
phase: 07-execution-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/execute-phase.js
autonomous: true

must_haves:
  truths:
    - "discoverPlans finds all PLAN.md files and detects which have matching SUMMARY.md"
    - "groupByWave returns plans grouped by wave number in ascending order"
    - "buildTaskCommitMessage produces conventional commit format: {type}({planId}): {description}"
    - "buildPlanCommitMessage produces metadata commit with task list and SUMMARY path"
    - "buildSummaryContent generates YAML frontmatter + markdown body matching upstream template"
    - "updateStateAfterPlan updates ROADMAP.md checkbox, progress table, and STATE.md position"
    - "getPhaseCompletionStatus returns whether all plans in a phase are complete"
  artifacts:
    - path: "src/execute-phase.js"
      provides: "Plan discovery, wave grouping, commit message builders, SUMMARY template, state update orchestration, and phase completion check"
      exports: ["discoverPlans", "groupByWave", "buildTaskCommitMessage", "buildPlanCommitMessage", "buildSummaryContent", "updateStateAfterPlan", "getPhaseCompletionStatus"]
      min_lines: 200
  key_links:
    - from: "src/execute-phase.js"
      to: "src/state-read.js"
      via: "parsePlanFrontmatter, readRoadmap, readState, parseRoadmapProgress, readPlanningConfig imports"
      pattern: "import.*state-read"
    - from: "src/execute-phase.js"
      to: "src/state-write.js"
      via: "updateStatePosition, updateRoadmapProgress, updatePlanCheckbox imports"
      pattern: "import.*state-write"
    - from: "src/execute-phase.js"
      to: "src/state-init.js"
      via: "renderProgressBar import"
      pattern: "import.*state-init"
---

<objective>
Create the execute-phase Node.js helper module with plan discovery, wave-based ordering, atomic commit message builders, SUMMARY.md template generation, and state update orchestration.

Purpose: This is the foundational module for Phase 7. It provides all the orchestration logic that the Cline workflow (gsd-execute-phase.md) will call. Unlike upstream GSD which spawns subagents for execution, Cline-GSD executes in the main context -- so this module handles everything except the actual task execution (which Cline does inline). All existing building blocks from Phases 3 and 6 are reused: parsePlanFrontmatter, updateStatePosition, updateRoadmapProgress, updatePlanCheckbox, getPhaseDetails, readPlanningConfig, renderProgressBar.

Output: `src/execute-phase.js` module with 7 exported functions.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-execution-workflow/07-RESEARCH.md
@src/state-read.js
@src/state-write.js
@src/state-init.js
@src/discuss-phase.js
@src/plan-phase.js
@src/map-codebase.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/execute-phase.js helper module</name>
  <files>src/execute-phase.js</files>
  <action>
Create `src/execute-phase.js` following the established module pattern from `src/plan-phase.js` and `src/map-codebase.js`. All functions use the error-return pattern `{ success, data, error }`.

Module-level doc comment listing all exports.

Imports:
```javascript
import { readdir, readFile } from 'node:fs/promises';
import path from 'node:path';
import { parsePlanFrontmatter, readRoadmap, readState, parseRoadmapProgress, readPlanningConfig } from './state-read.js';
import { updateStatePosition, updateRoadmapProgress, updatePlanCheckbox } from './state-write.js';
import { renderProgressBar } from './state-init.js';
```

**Exported functions (7 total):**

1. **`discoverPlans(phaseDir)`** (async)
   - Reads the phase directory for all `*-PLAN.md` files
   - Also reads `*-SUMMARY.md` files to determine completion status
   - For each PLAN.md: extracts planId from filename (`07-01-PLAN.md` -> `07-01`), reads content, parses frontmatter via `parsePlanFrontmatter()`
   - Returns `{ success: true, data: { plans: Array, completed: Array, incomplete: Array } }` where each plan object has: `{ id, file, path, wave, autonomous, dependsOn, filesModified, isComplete }`
   - Plans sorted by filename (natural order)
   - A plan is complete when its matching SUMMARY.md exists (e.g., `07-01-SUMMARY.md` for `07-01-PLAN.md`)
   - Handle edge case: phaseDir doesn't exist or has no PLAN.md files

2. **`groupByWave(plans)`** (sync)
   - Takes array of plan objects (from discoverPlans)
   - Groups plans by their `wave` property into a Map<number, Array>
   - Returns `{ success: true, data: { waves: Map<number, Array>, waveOrder: number[] } }` where `waveOrder` is sorted ascending wave numbers
   - Pure function, no I/O

3. **`buildTaskCommitMessage(type, planId, description, details = [])`** (sync)
   - Builds a conventional commit message for a task
   - Format: `{type}({planId}): {description}` with optional `\n\n- detail1\n- detail2` body
   - Valid types: feat, fix, test, refactor, perf, chore, docs, style
   - Returns the formatted string directly (not wrapped in error-return -- pure formatter)

4. **`buildPlanCommitMessage(planId, planName, taskNames, summaryPath)`** (sync)
   - Builds the metadata commit message for plan completion
   - Format: `docs({planId}): complete {planName}\n\nTasks completed: N/N\n- task1\n- task2\n\nSUMMARY: {summaryPath}`
   - Returns the formatted string directly (pure formatter)

5. **`buildSummaryContent(data)`** (sync)
   - Generates complete SUMMARY.md content from execution data
   - Parameter `data` is an object with these fields:
     - `phase` (string, e.g., "07-execution-workflow")
     - `plan` (string, e.g., "01")
     - `title` (string, plan title)
     - `oneLiner` (string, substantive one-liner for the summary)
     - `subsystem` (string, e.g., "orchestration")
     - `tags` (string[], e.g., ["execution", "commits"])
     - `requires` (string[], dependencies on prior phases)
     - `provides` (string[], what this delivers)
     - `affects` (string[], future phases needing this)
     - `techAdded` (string[], new libraries)
     - `patterns` (string[], patterns established)
     - `filesCreated` (Array of {path, purpose})
     - `filesModified` (Array of {path, purpose})
     - `decisions` (Array of {decision, rationale})
     - `duration` (string, e.g., "3 min")
     - `completed` (string, ISO date "YYYY-MM-DD")
     - `tasks` (Array of {name, commit, type, files})
     - `accomplishments` (string[])
     - `deviations` (string, "None" or deviation text)
     - `issues` (string, "None" or issues text)
     - `nextReadiness` (string)
   - Outputs YAML frontmatter between `---` delimiters matching the upstream template structure at `/Users/memehalis/.claude/get-shit-done/templates/summary.md`
   - Outputs markdown body with sections: title + one-liner, Performance, Accomplishments, Task Commits, Files Created/Modified, Decisions Made, Deviations, Issues, Next Phase Readiness, Self-Check footer
   - Returns the formatted string directly (pure template function)

6. **`updateStateAfterPlan(planningDir, phaseNum, planNum, phaseName, totalPlansInPhase, completedInPhase)`** (async)
   - Orchestrates all state updates after a plan completes
   - Step 1: Toggle plan checkbox in ROADMAP.md via `updatePlanCheckbox(planningDir, phaseNum, planNum, true)`
   - Step 2: Determine phase status -- if `completedInPhase >= totalPlansInPhase` then status is `'Complete'` with today's date, otherwise `'In progress'` with `'-'`
   - Step 3: Update ROADMAP.md progress table row via `updateRoadmapProgress(planningDir, phaseNum, completedInPhase, totalPlansInPhase, status, dateStr)`
   - Step 4: Calculate global progress -- read ROADMAP.md via `readRoadmap(planningDir)`, parse progress via `parseRoadmapProgress()` to get total plans and completed plans across ALL phases
   - Step 5: Update STATE.md position via `updateStatePosition(planningDir, { phaseNum, totalPhases, phaseName, planNum: completedInPhase, totalPlans: totalPlansInPhase, status: phaseStatus, lastActivity: dateActivity, completedPlans: globalCompleted, totalPlansGlobal: globalTotal })`
     - `totalPhases` comes from the progress table row count
     - `phaseStatus` is `'Phase complete'` if all plans done, else `'In progress'`
     - `lastActivity` is `'{today} -- Completed {paddedPhase}-{paddedPlan}-PLAN.md'`
   - Returns `{ success: true, data: { phaseComplete: boolean, globalProgress: { completed, total, pct } } }`
   - Uses error-return pattern; wraps everything in try/catch

7. **`getPhaseCompletionStatus(phaseDir)`** (async)
   - Quick check: are all plans in a phase complete?
   - Reads directory, counts PLAN.md and SUMMARY.md files
   - Returns `{ success: true, data: { totalPlans, completedPlans, allComplete: boolean, incompletePlans: string[] } }`
   - `incompletePlans` lists plan IDs that lack SUMMARY.md

**Implementation notes:**
- Follow the exact code style from `src/plan-phase.js` and `src/map-codebase.js`
- Use a `padPhase()` helper (same pattern as plan-phase.js) for zero-padding
- Functions 3, 4, and 5 are pure formatters -- they return strings directly (not wrapped in `{ success, data }`). This matches the pattern where template/formatting functions are simple returns, while I/O functions use error-return.
- All async functions use error-return pattern with try/catch
- Do NOT import from agent-spawn.js or agent-collect.js -- execution is main-context only
  </action>
  <verify>
Run: `node -e "import { discoverPlans, groupByWave, buildTaskCommitMessage, buildPlanCommitMessage, buildSummaryContent, updateStateAfterPlan, getPhaseCompletionStatus } from './src/execute-phase.js'; console.log('imports OK'); const msg = buildTaskCommitMessage('feat', '07-01', 'test commit'); console.log('commit msg:', msg); const planMsg = buildPlanCommitMessage('07-01', 'test plan', ['task1', 'task2'], '.planning/phases/07/07-01-SUMMARY.md'); console.log('plan msg length:', planMsg.length); console.log('PASS');"` -- should print imports OK, a formatted commit message, a plan message length > 0, and PASS.
  </verify>
  <done>
Module exports 7 functions: discoverPlans (plan discovery with completion detection), groupByWave (wave-based grouping), buildTaskCommitMessage (conventional commit format), buildPlanCommitMessage (metadata commit format), buildSummaryContent (SUMMARY.md template matching upstream), updateStateAfterPlan (STATE.md + ROADMAP.md updates), getPhaseCompletionStatus (quick completion check). All async functions use error-return pattern. Pure functions return strings directly. No agent-spawn dependencies (main-context only).
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify module integration with existing state modules</name>
  <files>src/execute-phase.js</files>
  <action>
After creating the module, verify it integrates correctly with the existing state infrastructure by running a quick smoke test:

```bash
node -e "
import { discoverPlans, groupByWave, buildTaskCommitMessage, buildPlanCommitMessage, buildSummaryContent, updateStateAfterPlan, getPhaseCompletionStatus } from './src/execute-phase.js';

// Test 1: groupByWave with mock plans
const mockPlans = [
  { id: '07-01', wave: 1 },
  { id: '07-02', wave: 1 },
  { id: '07-03', wave: 2 },
];
const grouped = groupByWave(mockPlans);
console.log('Waves:', grouped.data.waveOrder);
console.assert(grouped.success === true, 'groupByWave should succeed');
console.assert(grouped.data.waveOrder.length === 2, 'Should have 2 waves');

// Test 2: buildTaskCommitMessage
const msg = buildTaskCommitMessage('feat', '07-01', 'create execute-phase module', ['Plan discovery', 'Wave grouping']);
console.assert(msg.startsWith('feat(07-01):'), 'Should start with type(planId):');
console.assert(msg.includes('- Plan discovery'), 'Should include details');

// Test 3: buildSummaryContent produces valid markdown
const summary = buildSummaryContent({
  phase: '07-execution-workflow', plan: '01', title: 'Test Summary',
  oneLiner: 'Execute-phase helper module with 7 exports',
  subsystem: 'orchestration', tags: ['execution'],
  requires: [], provides: ['execute-phase module'], affects: ['08-verification'],
  techAdded: [], patterns: [], filesCreated: [{ path: 'src/execute-phase.js', purpose: 'helper module' }],
  filesModified: [], decisions: [], duration: '3 min', completed: '2026-02-05',
  tasks: [{ name: 'Task 1', commit: 'abc123', type: 'feat', files: ['src/execute-phase.js'] }],
  accomplishments: ['Created module'], deviations: 'None', issues: 'None',
  nextReadiness: 'Ready for workflow creation'
});
console.assert(summary.includes('---'), 'Should have frontmatter delimiters');
console.assert(summary.includes('## Accomplishments'), 'Should have Accomplishments section');

// Test 4: discoverPlans on non-existent dir returns error
const result = await discoverPlans('/tmp/nonexistent-phase-dir-12345');
console.assert(result.success === false, 'Should fail for non-existent dir');

// Test 5: getPhaseCompletionStatus on non-existent dir returns error
const status = await getPhaseCompletionStatus('/tmp/nonexistent-phase-dir-12345');
console.assert(status.success === false, 'Should fail for non-existent dir');

console.log('All smoke tests PASS');
"
```

If any assertion fails, fix the module and re-run until all pass.
  </action>
  <verify>
The smoke test above should print "All smoke tests PASS" with no assertion errors.
  </verify>
  <done>
Module integrates correctly with existing state modules. All 7 exports are importable. Pure functions produce correct output formats. Async functions handle error cases gracefully with error-return pattern. Commit messages follow conventional format. SUMMARY.md template has correct sections.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import { discoverPlans, groupByWave, buildTaskCommitMessage, buildPlanCommitMessage, buildSummaryContent, updateStateAfterPlan, getPhaseCompletionStatus } from './src/execute-phase.js'; console.log('OK');"` imports cleanly
2. `groupByWave` correctly groups mock plans by wave number
3. `buildTaskCommitMessage` produces `{type}({planId}): {desc}` format
4. `buildPlanCommitMessage` includes task list and SUMMARY path
5. `buildSummaryContent` produces YAML frontmatter + markdown body
6. `discoverPlans` returns error for non-existent directories
7. `getPhaseCompletionStatus` returns error for non-existent directories
8. No imports from agent-spawn.js or agent-collect.js
</verification>

<success_criteria>
- `src/execute-phase.js` exports 7 functions with correct signatures
- Pure functions return strings; async functions use error-return pattern
- SUMMARY.md template matches upstream structure (frontmatter + body sections)
- Commit message builders enforce conventional commit format
- State update orchestration calls existing state-write.js functions correctly
- Module has zero new dependencies (uses only existing codebase modules)
</success_criteria>

<output>
After completion, create `.planning/phases/07-execution-workflow/07-01-SUMMARY.md`
</output>
