---
phase: 03-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/state-init.js]
autonomous: true

must_haves:
  truths:
    - ".planning/ directory can be initialized with correct upstream-matching structure"
    - "Template files are created with correct sections and placeholders"
    - "Phase subdirectories follow XX-kebab-name convention"
    - "Only .planning/ and .planning/phases/ created during init (not codebase/, research/, todos/, debug/)"
  artifacts:
    - path: "src/state-init.js"
      provides: "Directory initialization and template file creation"
      exports: ["ensurePlanningDir", "ensurePhaseDir", "initProjectFiles"]
      min_lines: 120
  key_links:
    - from: "src/state-init.js"
      to: "node:fs/promises"
      via: "mkdir, writeFile, access"
      pattern: "import.*from 'node:fs/promises'"
    - from: "src/state-init.js"
      to: "node:path"
      via: "path.join for cross-platform paths"
      pattern: "import.*from 'node:path'"
---

<objective>
Create the state initialization module that sets up .planning/ directory structure and populates template files matching upstream GSD exactly.

Purpose: This is the foundation for all state management -- every GSD workflow starts by checking for or creating .planning/. Without this, no project state can persist.
Output: src/state-init.js with directory creation and template rendering functions
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-state-management/03-RESEARCH.md

@src/agent-collect.js (reference for error-return pattern and fs/promises usage)
@src/output.js (reference for picocolors usage)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state-init.js with directory and template functions</name>
  <files>src/state-init.js</files>
  <action>
Create src/state-init.js with the following exports, all using the error-return pattern ({ success, data, error }) established in agent-collect.js:

**ensurePlanningDir(projectRoot)**
- Creates .planning/ directory and .planning/phases/ subdirectory using mkdir with { recursive: true }
- Does NOT create codebase/, research/, todos/, or debug/ (those are created on-demand by their respective commands, per upstream behavior)
- Returns { success: true, data: { planningDir: absolutePath } } or error

**ensurePhaseDir(planningDir, phaseNum, phaseName)**
- Creates .planning/phases/XX-kebab-name/ directory
- Zero-pads phase number: String(phaseNum).padStart(2, '0')
- Slugifies name: lowercase, replace non-alphanumeric with hyphens, trim leading/trailing hyphens
- Returns { success: true, data: { phaseDir: absolutePath, dirName: 'XX-kebab-name' } } or error

**initProjectFiles(planningDir, options)**
- options: { projectName, coreValue, totalPhases, currentPhase, date }
- Creates these template files (only if they don't already exist -- check with fs.access first):
  - STATE.md -- exact upstream format with sections: Project Reference, Current Position, Performance Metrics, Accumulated Context, Session Continuity
  - config.json -- full upstream structure (mode, depth, workflow, planning, parallelization, gates, safety)
  - PROJECT.md -- skeleton with What This Is, Core Value, Requirements, Context, Constraints, Key Decisions
  - REQUIREMENTS.md -- skeleton with v1 Requirements section
  - ROADMAP.md -- skeleton with Overview, Phases, Phase Details, Progress sections
- Use simple string template interpolation with {{placeholder}} style replaced by values
- Date format: YYYY-MM-DD via new Date().toISOString().split('T')[0]
- Progress bar: renderProgressBar(0, 0) produces "[░░░░░░░░░░] 0%"

**renderProgressBar(completedPlans, totalPlans)**
- Internal helper (also exported for reuse in state-write.js)
- pct = totalPlans > 0 ? Math.round((completedPlans / totalPlans) * 100) : 0
- filled = Math.round(pct / 10) using Unicode block chars
- Return string: [███░░░░░░░] NN%

**Cline adaptations in templates (per locked decision):**
- Any command references use /gsd-name format (not /gsd:name)
- No execution_context references to ~/.claude/ paths

**Important implementation notes:**
- Use import { mkdir, writeFile, readFile, access } from 'node:fs/promises' and import { constants } from 'node:fs'
- ESM-only (export function, not module.exports)
- Do NOT import from output.js -- this module is pure file I/O with no terminal output
- config.json: write with JSON.stringify(config, null, 2)
- Skip file creation if file already exists (idempotent init)
  </action>
  <verify>
Run: node -e "import('./src/state-init.js').then(m => console.log(Object.keys(m)))"
Expected output includes: ensurePlanningDir, ensurePhaseDir, initProjectFiles, renderProgressBar

Run: node -e "import('./src/state-init.js').then(m => console.log(m.renderProgressBar(3, 10)))"
Expected output: [███░░░░░░░] 30%
  </verify>
  <done>
src/state-init.js exists with 4 exported functions. ensurePlanningDir creates .planning/ and .planning/phases/. ensurePhaseDir creates zero-padded phase directories. initProjectFiles creates STATE.md, config.json, PROJECT.md, REQUIREMENTS.md, ROADMAP.md from templates (skipping if already exists). renderProgressBar produces correct progress string. All functions return { success, data, error } pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add npm test script and verify init module</name>
  <files>package.json</files>
  <action>
Add a test:state script to package.json scripts section:
"test:state": "node scripts/test-state.js"

This just registers the script path. The actual test script will be created in plan 03 after all three state modules exist. This task ensures the package.json is updated now while this plan owns it (no file conflicts with plan 02).

Also verify the state-init module loads correctly by running:
node -e "import('./src/state-init.js').then(m => { const keys = Object.keys(m); console.log('Exports:', keys.length, keys); if (!keys.includes('ensurePlanningDir')) process.exit(1); })"
  </action>
  <verify>
Run: node -e "import('./package.json', { with: { type: 'json' } }).then(m => console.log(m.default.scripts))"
Or: node -c "require is not valid in ESM" -- just check that package.json has test:state script by reading the file.
  </verify>
  <done>
package.json contains "test:state": "node scripts/test-state.js" in scripts section. state-init.js loads without errors.
  </done>
</task>

</tasks>

<verification>
1. src/state-init.js exists and exports 4 functions
2. renderProgressBar(5, 20) returns "[███░░░░░░░] 25%"
3. renderProgressBar(0, 0) returns "[░░░░░░░░░░] 0%"
4. renderProgressBar(10, 10) returns "[██████████] 100%"
5. Module loads without errors: node -e "import('./src/state-init.js')"
6. package.json has test:state script
</verification>

<success_criteria>
- state-init.js module loads and exports ensurePlanningDir, ensurePhaseDir, initProjectFiles, renderProgressBar
- All functions use error-return pattern (not throw)
- Templates match upstream GSD format (STATE.md sections, config.json structure)
- Phase directories use zero-padded naming (03-state-management, not 3-state-management)
- File creation is idempotent (skips existing files)
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-management/03-01-SUMMARY.md`
</output>
