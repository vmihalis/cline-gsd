---
phase: 03-state-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/state-read.js]
autonomous: true

must_haves:
  truths:
    - "STATE.md can be parsed into structured data (position, progress, decisions)"
    - "ROADMAP.md progress table can be parsed (phase names, plan counts, completion)"
    - "PLAN.md frontmatter can be extracted (wave, depends_on, files_modified, autonomous)"
    - "Markdown section parsing works for any level-2 heading"
  artifacts:
    - path: "src/state-read.js"
      provides: "State file parsing and reading"
      exports: ["readState", "readRoadmap", "readPlanFrontmatter", "parseSections", "readPlanningConfig"]
      min_lines: 150
  key_links:
    - from: "src/state-read.js"
      to: "node:fs/promises"
      via: "readFile for loading .md and .json files"
      pattern: "import.*readFile.*from 'node:fs/promises'"
    - from: "src/state-read.js"
      to: ".planning/STATE.md"
      via: "readState parses STATE.md content"
      pattern: "readFile.*STATE\\.md"
    - from: "src/state-read.js"
      to: ".planning/ROADMAP.md"
      via: "readRoadmap parses progress table"
      pattern: "readFile.*ROADMAP\\.md"
---

<objective>
Create the state reading module that parses STATE.md, ROADMAP.md, PLAN.md frontmatter, and config.json into structured JavaScript objects.

Purpose: Every GSD workflow reads state before acting. This module provides the parsing layer that turns markdown files into actionable data structures.
Output: src/state-read.js with all parsing and reading functions
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-management/03-RESEARCH.md

@src/agent-collect.js (reference for error-return pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state-read.js with parsing functions</name>
  <files>src/state-read.js</files>
  <action>
Create src/state-read.js with the following exports. All file-reading functions use the error-return pattern ({ success, data, error }). Pure parsing functions (no I/O) return the parsed result directly.

**parseSections(content, level = 2)** -- Pure parser, no I/O
- Splits markdown content by heading level (default ## level 2)
- Returns object: { sectionName: sectionContent, ... }
- Section content is the text between this heading and the next same-level heading (trimmed)
- Include any text before the first heading as key '_preamble' (if non-empty)

**parseStatePosition(content)** -- Pure parser, no I/O
- Extracts from "Current Position" section:
  - phaseNum (int), totalPhases (int), phaseName (string)
  - planNum (int), totalPlans (int)
  - status (string), lastActivity (string)
  - progressPct (int) -- parsed from the progress bar line
- Uses regex on known line formats:
  - "Phase: N of M (Name)"
  - "Plan: N of M in current phase"
  - "Status: ..."
  - "Progress: [...] NN%"
- Returns the parsed object or null if section not found

**parseRoadmapProgress(content)** -- Pure parser, no I/O
- Parses the progress table in ROADMAP.md
- Regex matches rows like: | 1. Installation & Foundation | 3/3 | Complete | 2026-02-05 |
- Pattern: /\|\s*(\d+)\.\s*(.+?)\s*\|\s*(\d+)\/(\d+)\s*\|\s*(\w[\w\s]*?)\s*\|\s*(.*?)\s*\|/g
- Returns: { phases: [{number, name, completedPlans, totalPlans, status, completedDate}], totalPlans, completedPlans }

**parsePlanFrontmatter(content)** -- Pure parser, no I/O
- Extracts YAML frontmatter between --- delimiters
- Parses ONLY top-level fields: phase, plan, type, wave, depends_on, files_modified, autonomous
- For scalar values: simple regex match per line
- For array values: handle both inline [a, b] and multi-line (- item) formats
- Does NOT attempt to parse must_haves deeply (per research recommendation -- leave as raw text for downstream consumers)
- Returns parsed object or null if no frontmatter found

**readState(planningDir)** -- File I/O with error-return
- Reads planningDir/STATE.md
- Calls parseSections and parseStatePosition on content
- Returns { success: true, data: { raw, sections, position } }

**readRoadmap(planningDir)** -- File I/O with error-return
- Reads planningDir/ROADMAP.md
- Calls parseRoadmapProgress on content
- Returns { success: true, data: { raw, progress } }

**readPlanFrontmatter(planFilePath)** -- File I/O with error-return
- Reads a PLAN.md file at the given path
- Calls parsePlanFrontmatter on content
- Returns { success: true, data: frontmatterObject }

**readPlanningConfig(planningDir)** -- File I/O with error-return
- Reads planningDir/config.json
- JSON.parse the content
- Returns { success: true, data: configObject }
- If file doesn't exist, returns default config (matching upstream defaults from research)

**Implementation notes:**
- import { readFile } from 'node:fs/promises' and import path from 'node:path'
- ESM-only exports
- Pure parsers are exported separately so they can be unit tested without filesystem
- parseStatePosition regex must handle the exact format in STATE.md: "Phase: 3 of 8 (State Management)"
- For parseRoadmapProgress, handle both "Complete" and "Not started" status values
- readPlanningConfig should merge loaded config with defaults (so missing keys get upstream defaults)
  </action>
  <verify>
Run: node -e "import('./src/state-read.js').then(m => console.log(Object.keys(m)))"
Expected: includes parseSections, parseStatePosition, parseRoadmapProgress, parsePlanFrontmatter, readState, readRoadmap, readPlanFrontmatter, readPlanningConfig

Run: node -e "
import { parseStatePosition } from './src/state-read.js';
const sample = 'Phase: 3 of 8 (State Management)\nPlan: 0 of 3 in current phase\nStatus: Ready to plan\nLast activity: 2026-02-05\n\nProgress: [███░░░░░░░] 25%';
const result = parseStatePosition(sample);
console.log(JSON.stringify(result));
"
Expected: phaseNum=3, totalPhases=8, phaseName="State Management", planNum=0, totalPlans=3, progressPct=25

Run: node -e "
import { parseRoadmapProgress } from './src/state-read.js';
const sample = '| 1. Installation | 3/3 | Complete | 2026-02-05 |\n| 2. Agent Infra | 2/2 | Complete | 2026-02-05 |\n| 3. State Mgmt | 0/3 | Not started | - |';
const result = parseRoadmapProgress(sample);
console.log(JSON.stringify(result));
"
Expected: totalPlans=8, completedPlans=5, phases array with 3 entries
  </verify>
  <done>
src/state-read.js exists with 8 exported functions. Pure parsers (parseSections, parseStatePosition, parseRoadmapProgress, parsePlanFrontmatter) work on string input without I/O. File readers (readState, readRoadmap, readPlanFrontmatter, readPlanningConfig) use error-return pattern. parseStatePosition correctly extracts phase/plan/status/progress from STATE.md format. parseRoadmapProgress correctly parses progress table rows. parsePlanFrontmatter extracts top-level YAML fields without deep must_haves parsing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify state-read.js against actual project files</name>
  <files>src/state-read.js</files>
  <action>
After creating state-read.js, verify it works against the actual .planning/ files in this project:

1. Run readState('.planning/') and confirm it parses the current STATE.md correctly:
   - position.phaseNum should be 3
   - position.totalPhases should be 8
   - position.phaseName should be "State Management"
   - position.progressPct should be 25

2. Run readRoadmap('.planning/') and confirm it parses ROADMAP.md correctly:
   - progress.totalPlans should be 8 (3+2+3)... actually check the real ROADMAP progress table
   - progress.completedPlans should be 5
   - progress.phases should have 8 entries

3. Run readPlanningConfig('.planning/') and confirm it returns the config:
   - data.mode should be "yolo"
   - data.depth should be "comprehensive"

If any parsing fails, fix the regex patterns in state-read.js to handle the actual file format. The real files are the ground truth.
  </action>
  <verify>
Run: node -e "
import { readState, readRoadmap, readPlanningConfig } from './src/state-read.js';
const [state, roadmap, config] = await Promise.all([
  readState('.planning'),
  readRoadmap('.planning'),
  readPlanningConfig('.planning')
]);
console.log('State:', state.success, 'phase:', state.data?.position?.phaseNum);
console.log('Roadmap:', roadmap.success, 'completed:', roadmap.data?.progress?.completedPlans);
console.log('Config:', config.success, 'mode:', config.data?.mode);
"
Expected: All three succeed, phase=3, completedPlans=5, mode="yolo"
  </verify>
  <done>
state-read.js correctly parses the actual .planning/ files in this project. readState returns position with phaseNum=3. readRoadmap returns progress with completedPlans=5. readPlanningConfig returns config with mode="yolo". All parsing functions are validated against real data.
  </done>
</task>

</tasks>

<verification>
1. src/state-read.js exists and exports 8 functions
2. parseSections splits markdown correctly by heading level
3. parseStatePosition extracts all fields from Current Position section
4. parseRoadmapProgress parses progress table into phase array with plan counts
5. parsePlanFrontmatter extracts wave, depends_on, autonomous from YAML
6. readState/readRoadmap/readPlanningConfig all work against actual project files
7. All file-reading functions use { success, data, error } return pattern
</verification>

<success_criteria>
- state-read.js loads without errors and exports all 8 functions
- Pure parsers work on string input (no filesystem dependency)
- File readers use error-return pattern consistently
- Parsing validated against actual .planning/ files in this project
- parseRoadmapProgress correctly calculates totalPlans and completedPlans
- parsePlanFrontmatter handles both inline and multi-line array formats
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-management/03-02-SUMMARY.md`
</output>
