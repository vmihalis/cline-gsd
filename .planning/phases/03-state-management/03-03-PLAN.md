---
phase: 03-state-management
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified: [src/state-write.js, scripts/test-state.js]
autonomous: true

must_haves:
  truths:
    - "STATE.md can be updated section-by-section without losing accumulated context"
    - "ROADMAP.md progress table can be updated with actual plan completion counts"
    - "STATE.md position updates correctly when phase/plan changes"
    - "Progress bar in STATE.md reflects completed plans / total plans"
    - "Test script validates all three state modules work together"
  artifacts:
    - path: "src/state-write.js"
      provides: "State file update operations"
      exports: ["updateStateSection", "updateStatePosition", "updateRoadmapProgress", "updatePlanCheckbox"]
      min_lines: 100
    - path: "scripts/test-state.js"
      provides: "Integration test for all state modules"
      min_lines: 80
  key_links:
    - from: "src/state-write.js"
      to: "src/state-read.js"
      via: "imports parseRoadmapProgress and parseSections for read-modify-write"
      pattern: "import.*from './state-read.js'"
    - from: "src/state-write.js"
      to: "src/state-init.js"
      via: "imports renderProgressBar for progress updates"
      pattern: "import.*renderProgressBar.*from './state-init.js'"
    - from: "src/state-write.js"
      to: "node:fs/promises"
      via: "readFile + writeFile for atomic section updates"
      pattern: "import.*readFile.*writeFile.*from 'node:fs/promises'"
    - from: "scripts/test-state.js"
      to: "src/state-init.js"
      via: "tests directory creation and template rendering"
      pattern: "import.*from.*state-init"
    - from: "scripts/test-state.js"
      to: "src/state-read.js"
      via: "tests parsing against created files"
      pattern: "import.*from.*state-read"
    - from: "scripts/test-state.js"
      to: "src/state-write.js"
      via: "tests section update and progress operations"
      pattern: "import.*from.*state-write"
---

<objective>
Create the state writing module and integration test that complete the state management lifecycle: init -> read -> write -> verify.

Purpose: Workflows need to update STATE.md position, ROADMAP.md progress, and PLAN.md checkboxes after executing work. This module provides those update operations. The test script validates all three modules work together end-to-end.
Output: src/state-write.js with update functions, scripts/test-state.js with integration test
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-management/03-RESEARCH.md

@.planning/phases/03-state-management/03-01-SUMMARY.md
@.planning/phases/03-state-management/03-02-SUMMARY.md

@src/state-init.js
@src/state-read.js
@src/agent-collect.js (reference for error-return pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state-write.js with update functions</name>
  <files>src/state-write.js</files>
  <action>
Create src/state-write.js with the following exports. All functions use the error-return pattern ({ success, data, error }).

**updateStateSection(planningDir, sectionName, newContent)**
- Reads STATE.md, finds the ## sectionName heading, replaces content between this heading and the next ## heading (or end of file)
- Uses parseSections from state-read.js to locate the section
- Writes the updated content back to STATE.md
- Returns { success: true, data: { updated: true } }
- CRITICAL: Must preserve all other sections unchanged. Read-modify-write pattern.

**updateStatePosition(planningDir, { phaseNum, totalPhases, phaseName, planNum, totalPlans, status, lastActivity, completedPlans, totalPlansGlobal })**
- Reads STATE.md
- Updates the "Current Position" section with new values using line-by-line replacement:
  - "Phase: N of M (Name)" line
  - "Plan: N of M in current phase" line
  - "Status: ..." line
  - "Last activity: DATE -- DESCRIPTION" line
  - "Progress: [BAR] NN%" line -- uses renderProgressBar from state-init.js
- Also updates "Current focus" line in Project Reference section
- Returns { success: true, data: { updated: true } }

**updateRoadmapProgress(planningDir, phaseNum, completedPlans, totalPlans, status, completedDate)**
- Reads ROADMAP.md
- Finds the progress table row matching phaseNum (regex: /\|\s*{phaseNum}\.\s*/)
- Updates that row's completedPlans/totalPlans, status, and completedDate columns
- Also updates the "Plans Complete" column format: "N/M"
- Writes back to ROADMAP.md
- Returns { success: true, data: { updated: true } }

**updatePlanCheckbox(planningDir, phaseNum, planNum, checked)**
- Reads ROADMAP.md
- Finds the plan checkbox line matching the plan: "- [ ] XX-NN-PLAN.md" or "- [x] XX-NN-PLAN.md"
- The phase number is zero-padded: String(phaseNum).padStart(2, '0')
- The plan number is zero-padded: String(planNum).padStart(2, '0')
- Toggles checkbox: checked=true -> "- [x]", checked=false -> "- [ ]"
- Writes back to ROADMAP.md
- Returns { success: true, data: { updated: true } }

**Implementation notes:**
- import { readFile, writeFile } from 'node:fs/promises'
- import path from 'node:path'
- import { parseSections, parseRoadmapProgress } from './state-read.js'
- import { renderProgressBar } from './state-init.js'
- ESM-only exports
- For updateStateSection: use regex replacement that matches ## heading through next ## heading or EOF
- Pitfall avoidance: Never overwrite STATE.md entirely -- always read first, modify section, write back
- Pitfall avoidance: When updating progress table row, preserve the phase name exactly as-is
  </action>
  <verify>
Run: node -e "import('./src/state-write.js').then(m => console.log(Object.keys(m)))"
Expected: includes updateStateSection, updateStatePosition, updateRoadmapProgress, updatePlanCheckbox

Run: node -e "
import { readState } from './src/state-read.js';
const before = await readState('.planning');
console.log('Current position:', before.data?.position?.phaseNum, before.data?.position?.status);
"
Confirm state-read still works (sanity check that imports resolve)
  </verify>
  <done>
src/state-write.js exists with 4 exported functions. updateStateSection replaces content within a specific ## section. updateStatePosition updates Current Position lines and progress bar. updateRoadmapProgress updates a specific phase row in the progress table. updatePlanCheckbox toggles plan checkboxes. All functions use read-modify-write pattern to preserve other content. All use error-return pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test script</name>
  <files>scripts/test-state.js</files>
  <action>
Create scripts/test-state.js that tests all three state modules end-to-end. Use the same pattern as scripts/test-agent-infra.js (Node built-in assert, no test framework).

**Test flow:**
1. Create a temp directory (os.tmpdir() + '/cline-gsd-test-' + Date.now())
2. Test ensurePlanningDir:
   - Call ensurePlanningDir(tempDir)
   - Assert .planning/ and .planning/phases/ exist
3. Test ensurePhaseDir:
   - Call ensurePhaseDir(planningDir, 1, 'Test Phase')
   - Assert .planning/phases/01-test-phase/ exists
4. Test initProjectFiles:
   - Call initProjectFiles(planningDir, { projectName: 'Test', coreValue: 'Testing', totalPhases: 3, currentPhase: 'Test Phase' })
   - Assert STATE.md, config.json, PROJECT.md, REQUIREMENTS.md, ROADMAP.md all exist
5. Test idempotent init:
   - Call initProjectFiles again with same args
   - Assert files unchanged (not overwritten)
6. Test renderProgressBar:
   - Assert renderProgressBar(0, 0) === '[░░░░░░░░░░] 0%'
   - Assert renderProgressBar(5, 10) === '[█████░░░░░] 50%'
   - Assert renderProgressBar(10, 10) === '[██████████] 100%'
7. Test parseSections:
   - Create sample markdown with ## sections
   - Assert parseSections returns correct section keys and content
8. Test parseStatePosition:
   - Read the created STATE.md
   - Assert phaseNum === 1, phaseName === 'Test Phase'
9. Test parseRoadmapProgress:
   - Create sample roadmap progress table string
   - Assert correct phase count, plan counts
10. Test parsePlanFrontmatter:
    - Create sample frontmatter string
    - Assert wave, depends_on, autonomous extracted correctly
11. Test updateStateSection:
    - Call updateStateSection(planningDir, 'Pending Todos', 'New todo item')
    - Read STATE.md back, assert 'New todo item' appears in Pending Todos section
    - Assert other sections unchanged
12. Test updateStatePosition:
    - Call updateStatePosition with phaseNum: 2, status: 'In progress'
    - Read STATE.md back, assert 'Phase: 2 of 3' appears
13. Clean up temp directory

**Output format:** Print test name and PASS/FAIL for each test. Print summary at end: "X/Y tests passed". Exit with code 1 if any fail.

**Import style:**
```javascript
import { ensurePlanningDir, ensurePhaseDir, initProjectFiles, renderProgressBar } from '../src/state-init.js';
import { parseSections, parseStatePosition, parseRoadmapProgress, parsePlanFrontmatter, readState, readPlanningConfig } from '../src/state-read.js';
import { updateStateSection, updateStatePosition } from '../src/state-write.js';
```
  </action>
  <verify>
Run: node scripts/test-state.js
Expected: All tests pass with summary "N/N tests passed" and exit code 0
  </verify>
  <done>
scripts/test-state.js exists and runs all integration tests. Tests cover: directory creation, template initialization, idempotent init, progress bar rendering, section parsing, state position parsing, roadmap progress parsing, frontmatter parsing, section updates, and position updates. All tests pass. Exit code 0 on success, 1 on any failure.
  </done>
</task>

</tasks>

<verification>
1. src/state-write.js exists and exports 4 functions
2. scripts/test-state.js exists and passes: node scripts/test-state.js
3. All state modules can be imported together without circular dependency issues
4. updateStateSection preserves other sections when updating one section
5. updateStatePosition correctly updates phase/plan/status/progress lines
6. Test creates temp directory, runs full lifecycle, cleans up
7. npm run test:state works (from package.json script added in plan 01)
</verification>

<success_criteria>
- state-write.js provides reliable read-modify-write operations for STATE.md and ROADMAP.md
- Integration test validates the full init -> read -> write lifecycle
- No data loss during section updates (critical requirement from research pitfall #4)
- Progress bar updates correctly when plan completion changes
- All three state modules (init, read, write) work together without import errors
- Test script runs and passes: "N/N tests passed"
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-management/03-03-SUMMARY.md`
</output>
