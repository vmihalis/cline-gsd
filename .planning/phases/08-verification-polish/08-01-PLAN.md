---
phase: 08-verification-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/verify-work.js
  - workflows/gsd/gsd-verify-work.md
autonomous: true

must_haves:
  truths:
    - "parseMustHaves extracts truths, artifacts, and key_links from PLAN.md frontmatter YAML"
    - "checkArtifactExists returns whether a file exists on disk"
    - "checkArtifactSubstantive detects stubs vs substantive files using line count and stub patterns"
    - "checkArtifactWired checks if a file is imported by other files in the project"
    - "buildVerificationContent generates VERIFICATION.md with pass/fail results for all must-have checks"
    - "buildUATContent generates UAT.md with frontmatter and per-test results"
    - "extractTestableDeliveries extracts testable items from SUMMARY.md content"
    - "/gsd-verify-work N runs must-haves verification and interactive UAT for a phase"
  artifacts:
    - path: "src/verify-work.js"
      provides: "Must-haves parsing, three-level artifact verification, UAT content generation, and verification report building"
      exports: ["parseMustHaves", "extractTestableDeliveries", "checkArtifactExists", "checkArtifactSubstantive", "checkArtifactWired", "buildUATContent", "buildVerificationContent"]
      min_lines: 200
    - path: "workflows/gsd/gsd-verify-work.md"
      provides: "Cline workflow for /gsd-verify-work command with automated must-haves checking and interactive UAT"
      min_lines: 150
  key_links:
    - from: "src/verify-work.js"
      to: "src/state-read.js"
      via: "parsePlanFrontmatter import for plan loading"
      pattern: "import.*state-read"
    - from: "src/verify-work.js"
      to: "src/execute-phase.js"
      via: "discoverPlans import for finding plans to verify"
      pattern: "import.*execute-phase"
    - from: "workflows/gsd/gsd-verify-work.md"
      to: "src/verify-work.js"
      via: "node -e import for verification functions"
      pattern: "import.*verify-work"
    - from: "workflows/gsd/gsd-verify-work.md"
      to: "src/execute-phase.js"
      via: "node -e import for plan discovery"
      pattern: "import.*execute-phase"
---

<objective>
Create the verify-work helper module and Cline workflow for post-execution verification.

Purpose: This plan delivers VER-01 (/gsd:verify-work UAT verification) and VER-03 (must-haves checking against actual codebase). The helper module provides parsers and checkers that the workflow orchestrates. Automated must-haves verification checks that files exist, are substantive (not stubs), and are wired (imported/used). Interactive UAT presents testable deliveries from SUMMARY.md files for the user to confirm pass/fail. Together they close the verification loop after plan execution.

Output: `src/verify-work.js` module with 7 exported functions and `workflows/gsd/gsd-verify-work.md` workflow file.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-verification-polish/08-RESEARCH.md
@src/state-read.js
@src/execute-phase.js
@src/discuss-phase.js
@src/state-init.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/verify-work.js helper module</name>
  <files>src/verify-work.js</files>
  <action>
Create `src/verify-work.js` following the established module pattern from `src/execute-phase.js` and `src/discuss-phase.js`. Module-level JSDoc comment listing all exports. All I/O functions use the error-return pattern `{ success, data, error }`. Pure parsers and formatters return values directly.

Imports:
```javascript
import { readFile, readdir, access } from 'node:fs/promises';
import path from 'node:path';
```

**Exported functions (7 total):**

1. **`parseMustHaves(content)`** (sync, pure parser)
   - Parse `must_haves` from PLAN.md content (full file content including frontmatter)
   - Extract frontmatter block between `---` delimiters
   - If no `must_haves:` field exists, return `null`
   - Parse `truths:` as array of quoted strings: `- "truth text"` -> `["truth text"]`
   - Parse `artifacts:` as array of objects, each with: `path` (string), `provides` (string), `exports` (string[], optional), `min_lines` (number, optional), `contains` (string, optional)
   - Parse `key_links:` as array of objects, each with: `from` (string), `to` (string), `via` (string), `pattern` (string, optional)
   - Use line-by-line regex parsing following the existing `parsePlanFrontmatter()` approach in state-read.js:
     - First extract the frontmatter text between `---` markers
     - Find `must_haves:` line, then parse indented sub-sections
     - For `truths:`, collect `- "..."` lines under it
     - For `artifacts:`, collect `- path:` blocks. Each artifact block starts with `- path:` and continues with indented fields (`provides:`, `exports:`, `min_lines:`, `contains:`)
     - For `key_links:`, collect `- from:` blocks similarly
   - Handle both inline array `[a, b]` and multi-line `- item` formats for `exports`
   - Return `{ truths: string[], artifacts: object[], key_links: object[] }` or `null`

2. **`extractTestableDeliveries(summaryContent)`** (sync, pure parser)
   - Parse SUMMARY.md content to extract testable deliveries
   - Look for the `## Accomplishments` section and extract bullet points
   - Look for the `## Task Commits` section and extract task names
   - Look for the `## Files Created/Modified` section and extract file paths
   - Return array of objects: `[{ name: string, type: 'accomplishment'|'task'|'file', detail: string }]`
   - If no content or no recognizable sections, return empty array

3. **`checkArtifactExists(filePath)`** (async, I/O with error-return)
   - Check if a file exists at the given path
   - Uses `access()` from node:fs/promises
   - Returns `{ success: true, data: { exists: boolean, path: filePath } }`
   - Wraps in try/catch; access failure means `exists: false`

4. **`checkArtifactSubstantive(filePath, options = {})`** (async, I/O with error-return)
   - Read file content and determine if it's substantive, a stub, or partial
   - `options.min_lines` (number, default 10) -- minimum line count
   - `options.exports` (string[], optional) -- expected export names to check
   - `options.contains` (string, optional) -- string that must appear in content
   - Stub detection patterns (regex): `/TODO/i`, `/FIXME/i`, `/placeholder/i`, `/coming soon/i`, `/lorem ipsum/i`, `/throw new Error\(['"]not implemented/i`, `/^\s*return\s*;?\s*$/m` (empty return)
   - Logic:
     - Read file content
     - Count non-empty lines
     - Check for stub patterns
     - If `options.exports`, check each expected export exists via `export (function|const|class|async function) NAME` or `export { NAME`
     - If `options.contains`, check content includes that string
     - Return `{ success: true, data: { status: 'SUBSTANTIVE'|'STUB'|'PARTIAL', lines, hasStubs, missingExports, missingContains } }`
   - `SUBSTANTIVE`: lines >= min_lines AND no stubs AND all exports present AND contains match
   - `STUB`: lines < min_lines OR has stubs
   - `PARTIAL`: some exports missing but otherwise OK, or contains missing

5. **`checkArtifactWired(filePath, projectRoot = '.')`** (async, I/O with error-return)
   - Check if the artifact is imported/referenced by other files in the project
   - Strategy: Get the basename of the file (e.g., `verify-work.js`), then search `src/`, `scripts/`, `workflows/` directories for files that reference this basename
   - Read each file in those directories and check for import/require patterns matching the basename
   - Skip self-references (same file)
   - Return `{ success: true, data: { wired: boolean, importedBy: string[] } }`
   - If the file is a workflow (.md), skip wiring check -- workflows are entry points, not imported. Return `{ wired: true, importedBy: ['entry-point'] }`

6. **`buildVerificationContent(data)`** (sync, pure formatter -- returns string directly)
   - Generate VERIFICATION.md content with must-haves check results
   - Parameter `data` is an object with:
     - `phase` (string, e.g., "08-verification-polish")
     - `phaseName` (string, e.g., "Verification & Polish")
     - `plans` (array of plan result objects, each with: `planId`, `truths`, `artifacts`, `keyLinks`)
       - Each `truths` entry: `{ text, status: 'pass'|'fail'|'skip' }`
       - Each `artifacts` entry: `{ path, exists, substantive, wired, status: 'pass'|'fail' }`
       - Each `keyLinks` entry: `{ from, to, via, found, status: 'pass'|'fail' }`
     - `created` (string, ISO date)
     - `summary` (object: `{ totalChecks, passed, failed, skipped }`)
   - Output format:
     ```
     ---
     status: {pass|fail}
     phase: {phase}
     created: {date}
     total: {totalChecks}
     passed: {passed}
     failed: {failed}
     ---

     # Phase {N}: {Name} - Verification

     ## Summary

     {passed}/{totalChecks} checks passed ({failed} failed, {skipped} skipped)

     ## Plan {planId}

     ### Truths
     - [x] "truth text" (or [ ] for fail)

     ### Artifacts
     | Path | Exists | Substantive | Wired | Status |
     |...table rows...|

     ### Key Links
     | From | To | Via | Found | Status |
     |...table rows...|
     ```
   - Return the formatted string directly

7. **`buildUATContent(data)`** (sync, pure formatter -- returns string directly)
   - Generate UAT.md content for user acceptance testing
   - Parameter `data` is an object with:
     - `phase` (string)
     - `phaseName` (string)
     - `tests` (array of test objects: `{ name, expected, result: 'pass'|'fail'|'skipped'|'pending', issue?, severity? }`)
     - `status` (string: 'pending'|'in-progress'|'passed'|'failed'|'diagnosed')
     - `created` (string, ISO date)
     - `updated` (string, ISO date)
   - Output format from research:
     ```
     ---
     status: {status}
     phase: {phase}
     created: {created}
     updated: {updated}
     total: {tests.length}
     passed: {count}
     failed: {count}
     skipped: {count}
     pending: {count}
     ---

     # Phase {N}: {Name} - UAT

     ## Test Results

     ### Test 1: {name}
     - **Expected:** {expected}
     - **Result:** {result}
     {if issue: - **Issue:** {issue}\n- **Severity:** {severity}}
     ```
   - Return the formatted string directly

**Implementation notes:**
- Follow the exact code style from `src/execute-phase.js`: module-level JSDoc, section comments with `// ---` separators, consistent function signature documentation
- Pure parsers (functions 1, 2) and pure formatters (functions 6, 7) return values directly
- I/O functions (3, 4, 5) use error-return pattern with try/catch
- For `parseMustHaves`, parse line-by-line within the frontmatter block. Track current section (`truths`, `artifacts`, `key_links`) and current object (for nested artifact/key_link fields). Use indentation level to detect nesting.
- Do NOT import from agent-spawn.js -- verification runs in main context
  </action>
  <verify>
Run: `node -e "import { parseMustHaves, extractTestableDeliveries, checkArtifactExists, checkArtifactSubstantive, checkArtifactWired, buildUATContent, buildVerificationContent } from './src/verify-work.js'; console.log('imports OK'); const mh = parseMustHaves('---\nmust_haves:\n  truths:\n    - \"test truth\"\n  artifacts:\n    - path: \"src/foo.js\"\n      provides: \"stuff\"\n  key_links: []\n---\n'); console.log('truths:', mh?.truths?.length); console.log('artifacts:', mh?.artifacts?.length); const uat = buildUATContent({ phase: '08', phaseName: 'Test', tests: [{ name: 't1', expected: 'works', result: 'pass' }], status: 'passed', created: '2026-02-06', updated: '2026-02-06' }); console.log('UAT has frontmatter:', uat.includes('---')); console.log('PASS');"` -- should print imports OK, truths: 1, artifacts: 1, UAT has frontmatter: true, and PASS.
  </verify>
  <done>
Module exports 7 functions: parseMustHaves (frontmatter YAML parser for must_haves), extractTestableDeliveries (SUMMARY.md parser), checkArtifactExists (file existence), checkArtifactSubstantive (stub/substantive/partial detection with line counts and patterns), checkArtifactWired (import/reference tracing), buildVerificationContent (VERIFICATION.md generator), buildUATContent (UAT.md generator). Pure parsers and formatters return values directly. I/O functions use error-return pattern. No agent-spawn dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workflows/gsd/gsd-verify-work.md workflow</name>
  <files>workflows/gsd/gsd-verify-work.md</files>
  <action>
Create `workflows/gsd/gsd-verify-work.md` following the established workflow patterns from `gsd-execute-phase.md` and `gsd-plan-phase.md`.

Frontmatter:
```yaml
---
description: Verify completed phase work with automated must-haves checking and interactive UAT
---
```

Title: `# /gsd-verify-work -- Verify Completed Work`

Opening paragraph: This workflow verifies completed phase work through two mechanisms: (1) automated must-haves checking against the actual codebase, and (2) interactive user acceptance testing (UAT). It runs in the main Cline context. Must-haves verification checks that planned artifacts exist, are substantive, and are wired into the codebase. UAT presents testable deliveries from SUMMARY.md files for user confirmation.

**Step 1: Parse phase number and load state**
- Extract phase number from user input. If not provided, read STATE.md for current/last completed phase.
- Load state and config:
```bash
node -e "
import { readState, readPlanningConfig } from './src/state-read.js';
import { getPhaseDetails } from './src/discuss-phase.js';
const state = await readState('.planning');
const config = await readPlanningConfig('.planning');
const phase = await getPhaseDetails('.planning', PHASE_NUM);
console.log(JSON.stringify({ state: state.data?.position, config: config.data, phase: phase.data }, null, 2));
"
```
- If phase not found, stop with error.
- Check if phase execution is complete (all plans have SUMMARY.md):
```bash
node -e "
import { getPhaseCompletionStatus } from './src/execute-phase.js';
const status = await getPhaseCompletionStatus('PHASE_DIR_PATH');
console.log(JSON.stringify(status, null, 2));
"
```
- If phase is incomplete, warn: "Phase {N} has incomplete plans. Verification may be partial. Continue anyway?"

**Step 2: Automated must-haves verification**
- Discover all plans in the phase:
```bash
node -e "
import { discoverPlans } from './src/execute-phase.js';
const result = await discoverPlans('PHASE_DIR_PATH');
console.log(JSON.stringify(result.data.plans.map(p => ({ id: p.id, path: p.path })), null, 2));
"
```
- For each plan, read the PLAN.md content and parse must_haves:
```bash
node -e "
import { readFile } from 'node:fs/promises';
import { parseMustHaves } from './src/verify-work.js';
const content = await readFile('PLAN_PATH', 'utf-8');
const mustHaves = parseMustHaves(content);
console.log(JSON.stringify(mustHaves, null, 2));
"
```
- If must_haves is null (plan has no must_haves), skip that plan's verification.
- For each plan with must_haves:
  - **Check artifacts:**
    - For each artifact in `mustHaves.artifacts`:
      - Check existence: `checkArtifactExists(artifact.path)`
      - If exists, check substantive: `checkArtifactSubstantive(artifact.path, { min_lines: artifact.min_lines, exports: artifact.exports, contains: artifact.contains })`
      - If substantive, check wired: `checkArtifactWired(artifact.path)`
    - Record results per artifact
  - **Check key_links:**
    - For each key_link, read the `from` file and grep for the `pattern` regex
    - Record whether the pattern was found
  - **Record truths:**
    - Truths are observable behaviors -- they can't be fully automated
    - Mark truths as 'pass' if ALL supporting artifacts are substantive and wired
    - Mark truths as 'fail' if any supporting artifact is missing/stub
    - If no clear artifact mapping, mark as 'skip' (needs manual UAT)

- Generate VERIFICATION.md:
```bash
node -e "
import { buildVerificationContent } from './src/verify-work.js';
const content = buildVerificationContent({
  phase: 'PHASE_ID',
  phaseName: 'PHASE_NAME',
  plans: [PLAN_RESULTS],
  created: 'TODAY_DATE',
  summary: { totalChecks: N, passed: M, failed: K, skipped: J }
});
console.log(content);
"
```
- Write VERIFICATION.md to `.planning/phases/XX-name/{phase}-VERIFICATION.md`
- Report results:
```
## Must-Haves Verification

{passed}/{total} checks passed ({failed} failed, {skipped} skipped)

| Plan | Artifacts | Key Links | Status |
|------|-----------|-----------|--------|
| 08-01 | 2/2 pass | 4/4 pass | PASS |
| 08-02 | 2/2 pass | 2/2 pass | PASS |
```

**Step 3: Interactive UAT**
- Extract testable deliveries from SUMMARY.md files:
```bash
node -e "
import { readFile } from 'node:fs/promises';
import { extractTestableDeliveries } from './src/verify-work.js';
const content = await readFile('SUMMARY_PATH', 'utf-8');
const deliveries = extractTestableDeliveries(content);
console.log(JSON.stringify(deliveries, null, 2));
"
```
- Present success criteria from ROADMAP.md (from Step 1 phase details) as UAT tests
- For each success criterion:
  1. Show the criterion text
  2. Show supporting evidence (artifacts verified in Step 2, related accomplishments from SUMMARYs)
  3. Ask user: "Does this work as expected? (pass / fail / skip)"
  4. If fail: ask "What's the issue?" and "Severity? (blocker / major / minor)"
  5. Record result

- Generate UAT.md:
```bash
node -e "
import { buildUATContent } from './src/verify-work.js';
const content = buildUATContent({
  phase: 'PHASE_ID',
  phaseName: 'PHASE_NAME',
  tests: [TEST_RESULTS],
  status: 'STATUS',
  created: 'TODAY_DATE',
  updated: 'TODAY_DATE'
});
console.log(content);
"
```
- Write UAT.md to `.planning/phases/XX-name/{phase}-UAT.md`

**Step 4: Results and next steps**

If all checks pass and all UAT tests pass:
```
## Verification Complete

Phase {N}: {Name} -- ALL CHECKS PASSED

- Must-haves: {M}/{M} pass
- UAT: {K}/{K} pass

Phase is verified and ready.

---

**Next steps:**
- `/gsd-progress` -- see updated project status
{If more phases: - `/gsd-plan-phase {N+1}` -- plan next phase}
```

If any failures:
```
## Verification Found Issues

Phase {N}: {Name} -- {F} ISSUES FOUND

### Failed Checks
{list of failures with details}

### Recommended Actions
1. Fix the identified issues
2. Re-run `/gsd-verify-work {N}` to confirm fixes
{If UAT failures with diagnosed status: 3. Run `/gsd-debug` to investigate}
{If must-haves failures: 4. Run `/gsd-plan-phase {N} --gaps` to create fix plans}
```

**Behavioral Guidelines:**
- Verification is main-context only. No subagents for checking.
- Must-haves verification is automated (no user input needed for artifact checks).
- UAT is interactive -- always ask the user for pass/fail confirmation.
- Never skip VERIFICATION.md or UAT.md generation. They are the verification record.
- If a plan has no must_haves frontmatter, skip its automated check but still include it in UAT.
- Truths without clear artifact backing are marked 'skip' (needs manual verification in UAT).
- Keep output concise -- show summary tables, not every regex match.
- Suggest `/gsd-debug` for issues that need investigation.
- Suggest `/gsd-plan-phase N --gaps` for systematic gap closure.
  </action>
  <verify>
Verify the file exists and has correct structure:
- `head -5 workflows/gsd/gsd-verify-work.md` should show YAML frontmatter
- `grep -c "^## Step\|^\*\*Step" workflows/gsd/gsd-verify-work.md` should return 4 (four steps)
- `grep "verify-work.js" workflows/gsd/gsd-verify-work.md` should show references to the helper module
- `grep "parseMustHaves\|checkArtifactExists\|checkArtifactSubstantive\|checkArtifactWired\|buildVerificationContent\|buildUATContent\|extractTestableDeliveries" workflows/gsd/gsd-verify-work.md` should show all 7 helper function references
  </verify>
  <done>
Workflow file exists at `workflows/gsd/gsd-verify-work.md` with YAML frontmatter, 4 steps (load state, automated must-haves verification, interactive UAT, results/next steps), and behavioral guidelines. References all 7 exports from src/verify-work.js. Covers: three-level artifact checking (exists/substantive/wired), key_link pattern verification, truth status derivation, VERIFICATION.md generation, interactive UAT with pass/fail/skip per criterion, UAT.md generation, gap closure routing, and debug routing.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import { parseMustHaves, extractTestableDeliveries, checkArtifactExists, checkArtifactSubstantive, checkArtifactWired, buildUATContent, buildVerificationContent } from './src/verify-work.js'; console.log('OK');"` imports cleanly
2. `parseMustHaves` correctly parses truths, artifacts, and key_links from PLAN.md frontmatter
3. `checkArtifactExists` returns exists:true/false for real files
4. `checkArtifactSubstantive` detects stubs via regex patterns and line count thresholds
5. `checkArtifactWired` traces imports across src/, scripts/, workflows/ directories
6. `buildVerificationContent` produces VERIFICATION.md with frontmatter, summary table, and per-plan results
7. `buildUATContent` produces UAT.md with frontmatter and per-test results
8. `extractTestableDeliveries` parses SUMMARY.md accomplishments, tasks, and files
9. `workflows/gsd/gsd-verify-work.md` has 4 steps and references all helper functions
10. No references to agent-spawn.js (verification is main-context only)
</verification>

<success_criteria>
- `src/verify-work.js` exports 7 functions with correct signatures
- Pure parsers/formatters return values directly; I/O functions use error-return pattern
- Must-haves parser handles nested YAML frontmatter with truths, artifacts, and key_links
- Three-level artifact verification: exists -> substantive -> wired
- VERIFICATION.md and UAT.md templates have proper frontmatter and markdown structure
- Workflow covers both automated checking and interactive UAT
- Module has zero new dependencies (uses only node:fs/promises, node:path)
</success_criteria>

<output>
After completion, create `.planning/phases/08-verification-polish/08-01-SUMMARY.md`
</output>
