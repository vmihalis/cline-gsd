---
phase: 08-verification-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/debug-phase.js
  - workflows/gsd/gsd-debug.md
autonomous: true

must_haves:
  truths:
    - "buildDebugFileContent generates debug session files with frontmatter and all required sections"
    - "parseDebugFile extracts status, trigger, current focus, symptoms, eliminated, evidence, and resolution from debug files"
    - "updateDebugFile updates specific sections in an existing debug file"
    - "getActiveDebugSessions finds all non-resolved debug sessions in .planning/debug/"
    - "buildDebugPrompt generates investigation-guiding prompt from debug session state"
    - "/gsd-debug creates or resumes debug sessions with persistent state across /clear boundaries"
  artifacts:
    - path: "src/debug-phase.js"
      provides: "Debug session file creation, parsing, updating, discovery, and investigation prompt building"
      exports: ["buildDebugFileContent", "updateDebugFile", "parseDebugFile", "getActiveDebugSessions", "buildDebugPrompt"]
      min_lines: 150
    - path: "workflows/gsd/gsd-debug.md"
      provides: "Cline workflow for /gsd-debug command with systematic debugging methodology"
      min_lines: 120
  key_links:
    - from: "workflows/gsd/gsd-debug.md"
      to: "src/debug-phase.js"
      via: "node -e import for debug session management"
      pattern: "import.*debug-phase"
    - from: "src/debug-phase.js"
      to: "src/state-init.js"
      via: "ensurePhaseDir import for creating .planning/debug/ directory"
      pattern: "import.*state-init"
---

<objective>
Create the debug-phase helper module and Cline workflow for systematic debugging with persistent state.

Purpose: This plan delivers VER-02 (/gsd:debug systematic debugging with checkpoint state). The debug system uses persistent files in `.planning/debug/` to track investigation state across `/clear` boundaries. Each debug session follows the scientific method: gather symptoms, form hypothesis, test, eliminate/confirm, resolve. The file protocol matches the upstream GSD debugger pattern, adapted for main-context Cline execution (investigation only, no subagent code editing).

Output: `src/debug-phase.js` module with 5 exported functions and `workflows/gsd/gsd-debug.md` workflow file.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-verification-polish/08-RESEARCH.md
@src/state-init.js
@src/state-read.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/debug-phase.js helper module</name>
  <files>src/debug-phase.js</files>
  <action>
Create `src/debug-phase.js` following the established module pattern from `src/execute-phase.js` and `src/discuss-phase.js`. Module-level JSDoc comment listing all exports.

Imports:
```javascript
import { readFile, writeFile, readdir, mkdir } from 'node:fs/promises';
import path from 'node:path';
```

**Exported functions (5 total):**

1. **`buildDebugFileContent(data)`** (sync, pure formatter -- returns string directly)
   - Generate a new debug session file matching the upstream protocol
   - Parameter `data` is an object with:
     - `slug` (string, e.g., "login-redirect-loop")
     - `trigger` (string, e.g., "UAT failure: user cannot log in")
     - `status` (string, default "gathering")
     - `created` (string, ISO date)
     - `updated` (string, ISO date)
   - Output format (from upstream gsd-debugger.md):
     ```
     ---
     status: {status}
     trigger: {trigger}
     created: {created}
     updated: {updated}
     ---

     # Debug: {slug}

     ## Current Focus

     hypothesis: (none yet)
     test: (none yet)
     expecting: (none yet)
     next_action: Gather symptoms

     ## Symptoms

     expected: (to be filled)
     actual: (to be filled)
     errors: (to be filled)
     reproduction: (to be filled)
     started: {created}

     ## Eliminated

     (append-only -- hypotheses disproven with evidence)

     ## Evidence

     (append-only -- findings with implications)

     ## Resolution

     root_cause: (pending)
     fix: (pending)
     verification: (pending)
     files_changed: (pending)
     ```
   - Return the formatted string directly

2. **`parseDebugFile(content)`** (sync, pure parser)
   - Parse a debug session file into structured data
   - Extract frontmatter: `status`, `trigger`, `created`, `updated`
   - Extract sections using heading-based splitting (## level):
     - `currentFocus`: parse `hypothesis:`, `test:`, `expecting:`, `next_action:` key-value pairs
     - `symptoms`: parse `expected:`, `actual:`, `errors:`, `reproduction:`, `started:` key-value pairs
     - `eliminated`: raw text content (append-only section)
     - `evidence`: raw text content (append-only section)
     - `resolution`: parse `root_cause:`, `fix:`, `verification:`, `files_changed:` key-value pairs
   - Return `{ status, trigger, created, updated, slug, currentFocus, symptoms, eliminated, evidence, resolution }` or `null` if no frontmatter
   - For slug, extract from the `# Debug: {slug}` heading

3. **`updateDebugFile(filePath, updates)`** (async, I/O with error-return)
   - Read an existing debug file, apply updates, write it back
   - `updates` is an object with optional fields:
     - `status` (string) -- update frontmatter status
     - `currentFocus` (object with hypothesis, test, expecting, next_action) -- replace Current Focus section values
     - `symptoms` (object) -- replace Symptoms section values
     - `appendEliminated` (string) -- append to Eliminated section
     - `appendEvidence` (string) -- append to Evidence section
     - `resolution` (object) -- replace Resolution section values
   - For frontmatter status update: regex replace `status: old` -> `status: new`
   - For frontmatter updated field: always set to current ISO date
   - For section updates: find the section heading, replace key-value pairs
   - For append operations: find section heading, append text before the next section
   - Returns `{ success: true, data: { path: filePath, status: newStatus } }`
   - Error-return on any I/O failure

4. **`getActiveDebugSessions(planningDir)`** (async, I/O with error-return)
   - Find all non-resolved debug session files in `.planning/debug/`
   - Read the debug directory, filter for `DEBUG-*.md` files
   - Parse each file's frontmatter to get status
   - Return sessions where status is NOT 'resolved'
   - Returns `{ success: true, data: { sessions: Array<{ slug, status, trigger, path, created, updated }> } }`
   - If `.planning/debug/` doesn't exist, return empty sessions array (not an error)

5. **`buildDebugPrompt(sessionData)`** (sync, pure formatter -- returns string directly)
   - Generate an investigation-guiding prompt from the current debug session state
   - Parameter `sessionData` is the parsed debug file object (from parseDebugFile)
   - Prompt structure:
     ```
     ## Debug Session: {slug}

     **Status:** {status}
     **Trigger:** {trigger}

     ### Current Focus
     - Hypothesis: {hypothesis}
     - Test: {test}
     - Expecting: {expecting}
     - Next action: {next_action}

     ### Investigation Context
     {If symptoms filled: show symptoms}
     {If eliminated entries: show what's been ruled out}
     {If evidence entries: show collected evidence}

     ### Guidelines
     - Update the debug file BEFORE taking action (not after)
     - Use scientific method: hypothesis -> test -> confirm/eliminate
     - Append to Eliminated and Evidence sections (never delete entries)
     - When fixing, update status to "fixing" first
     - After fix, update status to "verifying" and run verification
     - When verified, update status to "resolved" with Resolution details
     ```
   - Return the formatted string directly

**Implementation notes:**
- Follow the exact code style from `src/execute-phase.js`: module-level JSDoc, section comments with `// ---` separators
- Pure formatter functions (1, 5) and pure parser (2) return values directly
- I/O functions (3, 4) use error-return pattern with try/catch
- The debug directory is `.planning/debug/` -- create it if it doesn't exist when writing
- Status transitions: gathering -> investigating -> fixing -> verifying -> resolved
- Slug generation for filenames: lowercase, replace spaces with hyphens, remove special chars
  </action>
  <verify>
Run: `node -e "import { buildDebugFileContent, parseDebugFile, updateDebugFile, getActiveDebugSessions, buildDebugPrompt } from './src/debug-phase.js'; console.log('imports OK'); const content = buildDebugFileContent({ slug: 'test-bug', trigger: 'test failure', status: 'gathering', created: '2026-02-06', updated: '2026-02-06' }); console.log('has frontmatter:', content.includes('---')); console.log('has sections:', content.includes('## Current Focus')); const parsed = parseDebugFile(content); console.log('parsed status:', parsed?.status); console.log('parsed slug:', parsed?.slug); const prompt = buildDebugPrompt(parsed); console.log('prompt has guidelines:', prompt.includes('Guidelines')); console.log('PASS');"` -- should print imports OK, has frontmatter: true, has sections: true, parsed status: gathering, parsed slug: test-bug, prompt has guidelines: true, and PASS.
  </verify>
  <done>
Module exports 5 functions: buildDebugFileContent (debug session file template matching upstream protocol), parseDebugFile (structured parsing of debug files), updateDebugFile (section-level updates with append support), getActiveDebugSessions (find non-resolved sessions), buildDebugPrompt (investigation-guiding prompt generation). Pure parsers/formatters return values directly. I/O functions use error-return pattern. Debug files persist in .planning/debug/ with status transitions: gathering -> investigating -> fixing -> verifying -> resolved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workflows/gsd/gsd-debug.md workflow</name>
  <files>workflows/gsd/gsd-debug.md</files>
  <action>
Create `workflows/gsd/gsd-debug.md` following the established workflow patterns from `gsd-execute-phase.md` and `gsd-verify-work.md`.

Frontmatter:
```yaml
---
description: Systematic debugging with persistent state using scientific method and hypothesis testing
---
```

Title: `# /gsd-debug -- Systematic Debugging`

Opening paragraph: This workflow provides systematic debugging with persistent investigation state. Debug sessions are stored in `.planning/debug/DEBUG-{slug}.md` files that persist across `/clear` boundaries, enabling long-running investigations. The methodology follows the scientific method: gather symptoms, form hypothesis, test, eliminate/confirm, resolve. All investigation happens in the main Cline context.

**Step 1: Check for active debug sessions**
```bash
node -e "
import { getActiveDebugSessions } from './src/debug-phase.js';
const result = await getActiveDebugSessions('.planning');
if (result.success && result.data.sessions.length > 0) {
  console.log('Active sessions:');
  result.data.sessions.forEach(s => console.log('  -', s.slug, '(' + s.status + ')'));
} else {
  console.log('No active debug sessions.');
}
"
```

If active sessions exist:
- Show list with status for each
- Ask: "Resume an existing session, or start new? (resume {slug} / new)"
- If resume: load that session file and jump to Step 3

If no active sessions or user chooses "new": continue to Step 2.

**Step 2: Create new debug session**
- Ask: "What issue are you debugging?" (get trigger description)
- Generate a slug from the description (lowercase, hyphens, 3-5 words)
- Ensure `.planning/debug/` directory exists:
```bash
mkdir -p .planning/debug
```
- Create debug file:
```bash
node -e "
import { buildDebugFileContent } from './src/debug-phase.js';
const content = buildDebugFileContent({
  slug: 'SLUG',
  trigger: 'TRIGGER_DESCRIPTION',
  status: 'gathering',
  created: 'TODAY_DATE',
  updated: 'TODAY_DATE'
});
console.log(content);
"
```
- Write to `.planning/debug/DEBUG-{slug}.md`
- Report: "Debug session created: .planning/debug/DEBUG-{slug}.md"

**Step 3: Load investigation context**
- Read the debug file and parse it:
```bash
node -e "
import { readFile } from 'node:fs/promises';
import { parseDebugFile, buildDebugPrompt } from './src/debug-phase.js';
const content = await readFile('.planning/debug/DEBUG-SLUG.md', 'utf-8');
const session = parseDebugFile(content);
const prompt = buildDebugPrompt(session);
console.log(prompt);
"
```
- Display the investigation context to orient Cline

**Step 4: Investigation loop (based on status)**

The investigation follows status transitions: gathering -> investigating -> fixing -> verifying -> resolved

**If status = "gathering":**
1. Ask: "Describe the symptoms. What did you expect vs what happened?"
2. Update debug file with symptoms:
```bash
node -e "
import { updateDebugFile } from './src/debug-phase.js';
await updateDebugFile('.planning/debug/DEBUG-SLUG.md', {
  symptoms: { expected: 'EXPECTED', actual: 'ACTUAL', errors: 'ERRORS', reproduction: 'REPRO' }
});
"
```
3. Analyze the symptoms and form an initial hypothesis
4. Update status to "investigating" and set Current Focus:
```bash
node -e "
import { updateDebugFile } from './src/debug-phase.js';
await updateDebugFile('.planning/debug/DEBUG-SLUG.md', {
  status: 'investigating',
  currentFocus: { hypothesis: 'HYPOTHESIS', test: 'HOW_TO_TEST', expecting: 'EXPECTED_IF_TRUE', next_action: 'NEXT_ACTION' }
});
"
```

**If status = "investigating":**
1. Read Current Focus for the current hypothesis
2. Execute the test described in `test` field
3. Compare results to `expecting` field
4. If hypothesis confirmed:
   - Append to Evidence section
   - Update status to "fixing"
   - Update Current Focus with fix plan
5. If hypothesis disproven:
   - Append to Eliminated section with evidence
   - Form new hypothesis
   - Update Current Focus

**If status = "fixing":**
1. Read Current Focus for the fix plan
2. Apply the fix (Cline performs the code changes in main context)
3. Update status to "verifying"
4. Update Current Focus with verification plan

**If status = "verifying":**
1. Run the verification described in Current Focus
2. If fix verified:
   - Update status to "resolved"
   - Update Resolution section with root_cause, fix, verification, files_changed
   - Report: "Debug session resolved: {slug}"
3. If verification fails:
   - Append failure to Evidence
   - Revert to "investigating" status
   - Form new hypothesis

**Step 5: Session management**

At any point, offer:
- "Continue investigating" -- loop back to Step 4
- "Pause session" -- save current state, exit (can resume later with `/gsd-debug`)
- "Abandon session" -- update status to "resolved" with resolution noting abandoned

When resolved:
```
## Debug Session Resolved: {slug}

**Root cause:** {root_cause}
**Fix applied:** {fix}
**Verified:** {verification}

Debug file: .planning/debug/DEBUG-{slug}.md

---

**Next steps:**
- `/gsd-verify-work {N}` -- re-run verification if this was from a UAT failure
- `/gsd-progress` -- check project status
```

**Behavioral Guidelines:**
- All investigation and fixing happens in the main Cline context. No subagents.
- Update the debug file BEFORE taking action, not after. This ensures the file always reflects what's about to happen, enabling reliable resume.
- Eliminated and Evidence sections are append-only. Never delete entries. This creates an audit trail.
- Status transitions are strict: gathering -> investigating -> fixing -> verifying -> resolved. Can loop back from verifying to investigating if fix doesn't work.
- Keep hypotheses specific and testable. "Something is wrong with auth" is bad. "JWT token expiry is set to 0 instead of 900 seconds" is good.
- Each investigation cycle should take 5-15 minutes. If it's taking longer, the hypothesis is too broad -- narrow it.
- When pausing, always save current state so resume picks up where you left off.
- Debug files persist across `/clear`. Always check for active sessions at start.
  </action>
  <verify>
Verify the file exists and has correct structure:
- `head -5 workflows/gsd/gsd-debug.md` should show YAML frontmatter
- `grep -c "^## Step\|^\*\*Step\|^\\*\\*If status" workflows/gsd/gsd-debug.md` should show step and status section references
- `grep "debug-phase.js" workflows/gsd/gsd-debug.md` should show references to the helper module
- `grep "buildDebugFileContent\|parseDebugFile\|updateDebugFile\|getActiveDebugSessions\|buildDebugPrompt" workflows/gsd/gsd-debug.md` should show all 5 helper function references
  </verify>
  <done>
Workflow file exists at `workflows/gsd/gsd-debug.md` with YAML frontmatter, 5 steps (check active sessions, create new session, load context, investigation loop, session management), and behavioral guidelines. References all 5 exports from src/debug-phase.js. Covers: session discovery and resume, new session creation, scientific method investigation (gathering -> investigating -> fixing -> verifying -> resolved), hypothesis testing with eliminate/confirm, persistent debug files in .planning/debug/, append-only evidence tracking, and session pause/resume/abandon.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import { buildDebugFileContent, parseDebugFile, updateDebugFile, getActiveDebugSessions, buildDebugPrompt } from './src/debug-phase.js'; console.log('OK');"` imports cleanly
2. `buildDebugFileContent` generates files matching upstream debug protocol
3. `parseDebugFile` extracts all sections from debug files
4. `updateDebugFile` handles status updates, section replacements, and appends
5. `getActiveDebugSessions` finds non-resolved sessions, handles missing directory
6. `buildDebugPrompt` generates investigation-guiding prompt
7. `workflows/gsd/gsd-debug.md` has 5 steps covering full debug lifecycle
8. Debug file protocol matches upstream gsd-debugger.md format
9. Status transitions are strict: gathering -> investigating -> fixing -> verifying -> resolved
10. No references to agent-spawn.js (debugging is main-context only)
</verification>

<success_criteria>
- `src/debug-phase.js` exports 5 functions with correct signatures
- Pure parsers/formatters return values directly; I/O functions use error-return pattern
- Debug file format matches upstream protocol exactly (frontmatter + 5 sections)
- Investigation loop follows scientific method with status transitions
- Append-only sections (Eliminated, Evidence) are never overwritten
- Workflow supports session resume across /clear boundaries
- Module has zero new dependencies (uses only node:fs/promises, node:path)
</success_criteria>

<output>
After completion, create `.planning/phases/08-verification-polish/08-02-SUMMARY.md`
</output>
