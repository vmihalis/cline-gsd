---
phase: 08-verification-polish
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/upstream-sync.js
  - workflows/gsd/gsd-sync-upstream.md
  - scripts/test-verify-work.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "getInstalledVersion reads the local package.json version"
    - "compareVersions correctly compares semver strings"
    - "checkUpstreamVersion fetches the latest published npm version"
    - "/gsd-sync-upstream checks version and guides re-installation"
    - "Integration test validates parseMustHaves with real PLAN.md frontmatter"
    - "Integration test validates checkArtifactExists and checkArtifactSubstantive"
    - "Integration test validates buildDebugFileContent and parseDebugFile roundtrip"
    - "Integration test validates buildUATContent and buildVerificationContent output format"
    - "package.json has test:verify-work script"
  artifacts:
    - path: "src/upstream-sync.js"
      provides: "Version comparison and upstream checking for sync workflow"
      exports: ["getInstalledVersion", "compareVersions", "checkUpstreamVersion"]
      min_lines: 50
    - path: "workflows/gsd/gsd-sync-upstream.md"
      provides: "Cline workflow for /gsd-sync-upstream command"
      min_lines: 60
    - path: "scripts/test-verify-work.js"
      provides: "Integration test for verify-work.js, debug-phase.js, and upstream-sync.js modules"
      min_lines: 200
    - path: "package.json"
      provides: "test:verify-work script entry"
      contains: "test:verify-work"
  key_links:
    - from: "scripts/test-verify-work.js"
      to: "src/verify-work.js"
      via: "import for parseMustHaves, checkArtifactExists, checkArtifactSubstantive, buildUATContent, buildVerificationContent"
      pattern: "import.*verify-work"
    - from: "scripts/test-verify-work.js"
      to: "src/debug-phase.js"
      via: "import for buildDebugFileContent, parseDebugFile"
      pattern: "import.*debug-phase"
    - from: "scripts/test-verify-work.js"
      to: "src/upstream-sync.js"
      via: "import for compareVersions, getInstalledVersion"
      pattern: "import.*upstream-sync"
    - from: "workflows/gsd/gsd-sync-upstream.md"
      to: "src/upstream-sync.js"
      via: "node -e import for version checking"
      pattern: "import.*upstream-sync"
---

<objective>
Create the upstream sync helper, workflow, integration test for Phase 8 modules, and update package.json.

Purpose: This plan delivers SYNC-02 (upstream sync mechanism) and comprehensive testing for all Phase 8 modules. The upstream sync workflow provides a simple version-check-and-reinstall pattern for staying current with the upstream GSD project. The integration test covers verify-work.js, debug-phase.js, and upstream-sync.js in a single test file following the established test pattern.

Output: `src/upstream-sync.js` module, `workflows/gsd/gsd-sync-upstream.md` workflow, `scripts/test-verify-work.js` integration test, and updated `package.json`.
</objective>

<execution_context>
@/Users/memehalis/.claude/get-shit-done/workflows/execute-plan.md
@/Users/memehalis/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-verification-polish/08-RESEARCH.md
@.planning/phases/08-verification-polish/08-01-SUMMARY.md
@.planning/phases/08-verification-polish/08-02-SUMMARY.md
@scripts/test-execute-phase.js
@src/verify-work.js
@src/debug-phase.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/upstream-sync.js helper module</name>
  <files>src/upstream-sync.js</files>
  <action>
Create `src/upstream-sync.js` following the established module pattern. Module-level JSDoc comment listing all exports. This is a small, focused module for version comparison and upstream checking.

Imports:
```javascript
import { readFile } from 'node:fs/promises';
import { execSync } from 'node:child_process';
import path from 'node:path';
```

**Exported functions (3 total):**

1. **`getInstalledVersion(projectRoot = '.')`** (async, I/O with error-return)
   - Read the local package.json and extract the version field
   - Returns `{ success: true, data: { version: string, path: string } }`
   - If package.json not found or version field missing: `{ success: false, error: '...' }`

2. **`compareVersions(current, latest)`** (sync, pure function -- returns value directly)
   - Compare two semver version strings (e.g., "1.0.0" vs "1.1.0")
   - Simple semver comparison: split by '.', compare major/minor/patch numerically
   - Returns an object: `{ needsUpdate: boolean, current, latest, comparison: 'up-to-date'|'behind'|'ahead' }`
   - 'behind' means current < latest (needs update)
   - 'ahead' means current > latest (local is ahead, unusual)
   - 'up-to-date' means current === latest

3. **`checkUpstreamVersion(packageName = 'cline-gsd')`** (async, I/O with error-return)
   - Check the latest published version on npm
   - Uses `execSync('npm view {packageName} version')` to get the latest version
   - Returns `{ success: true, data: { version: string, packageName: string } }`
   - If npm command fails (network error, package not published): `{ success: false, error: '...' }`
   - Trim whitespace from npm output

**Implementation notes:**
- This is intentionally a thin module. The research confirmed that upstream sync is primarily `npx cline-gsd@latest` for re-installation. The helper just provides version checking.
- Follow the exact code style from other src/ modules
- `compareVersions` is pure (no I/O) and returns the object directly (not wrapped in error-return)
- `getInstalledVersion` and `checkUpstreamVersion` use error-return pattern
  </action>
  <verify>
Run: `node -e "import { getInstalledVersion, compareVersions, checkUpstreamVersion } from './src/upstream-sync.js'; console.log('imports OK'); const cmp = compareVersions('1.0.0', '1.1.0'); console.log('comparison:', cmp.comparison); console.assert(cmp.needsUpdate === true, 'should need update'); const cmp2 = compareVersions('2.0.0', '1.0.0'); console.assert(cmp2.comparison === 'ahead', 'should be ahead'); const ver = await getInstalledVersion('.'); console.log('local version:', ver.data?.version); console.log('PASS');"` -- should print imports OK, comparison: behind, local version: 1.0.0, and PASS.
  </verify>
  <done>
Module exports 3 functions: getInstalledVersion (reads local package.json version), compareVersions (semver comparison returning needsUpdate, comparison status), checkUpstreamVersion (npm registry latest version lookup). Pure function returns value directly. I/O functions use error-return pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create workflows/gsd/gsd-sync-upstream.md workflow and integration test</name>
  <files>workflows/gsd/gsd-sync-upstream.md, scripts/test-verify-work.js</files>
  <action>
**Part A: Create `workflows/gsd/gsd-sync-upstream.md`**

Frontmatter:
```yaml
---
description: Check for upstream GSD updates and sync with latest version
---
```

Title: `# /gsd-sync-upstream -- Sync with Upstream GSD`

Opening paragraph: This workflow checks if a newer version of Cline-GSD is available and guides the user through updating. The Cline-GSD project tracks upstream GSD (glittercowboy/get-shit-done) as a reference implementation. Updates are delivered via npm re-installation.

**Step 1: Check current version**
```bash
node -e "
import { getInstalledVersion } from './src/upstream-sync.js';
const result = await getInstalledVersion('.');
console.log(JSON.stringify(result, null, 2));
"
```

Report: "Current version: {version}"

**Step 2: Check latest upstream version**
```bash
node -e "
import { checkUpstreamVersion, getInstalledVersion, compareVersions } from './src/upstream-sync.js';
const local = await getInstalledVersion('.');
const upstream = await checkUpstreamVersion();
if (local.success && upstream.success) {
  const cmp = compareVersions(local.data.version, upstream.data.version);
  console.log(JSON.stringify({ local: local.data.version, upstream: upstream.data.version, ...cmp }, null, 2));
} else {
  console.log('Could not check:', local.error || upstream.error);
}
"
```

Report comparison results:
- If up-to-date: "You're running the latest version ({version}). No update needed."
- If behind: "Update available: {current} -> {latest}"
- If ahead: "Local version ({current}) is ahead of published ({latest}). This is expected during development."
- If check failed: "Could not check upstream version. This may be a network issue or the package is not yet published."

**Step 3: Guide update (if needed)**

If update available:
```
## Update Available

**Current:** {current}
**Latest:** {latest}

### To update:

```bash
npx cline-gsd@latest
```

This will:
1. Download the latest version
2. Re-install workflows to your Cline config directory
3. Preserve your .planning/ directory and project state

### What's protected:
- `.planning/` directory (all project state)
- Your `config.json` settings
- Your project-specific files

### What gets updated:
- `workflows/gsd/` files (workflow definitions)
- `src/` module files (helper code)
- `bin/` installer files
```

If up-to-date:
```
No update needed.

---

**Also available:**
- `/gsd-progress` -- check project status
- `/gsd-verify-work` -- verify completed work
```

**Behavioral Guidelines:**
- Never auto-update. Always show the user what will change and let them decide.
- The `npx cline-gsd@latest` command handles the actual update. This workflow is just for checking and guidance.
- Protected files (.planning/, config.json) are never overwritten by the installer.
- If the package is not yet published to npm, that's expected during development.

---

**Part B: Create `scripts/test-verify-work.js` integration test**

Follow the EXACT test pattern from `scripts/test-execute-phase.js`:
- Shebang: `#!/usr/bin/env node`
- Module-level JSDoc with description, run command, npm script
- tmpdir isolation with cleanup in `finally` block
- `assert/strict` for assertions
- `test(name, fn)` helper with pass/fail tracking
- Sectioned by functionality with `--- Section Name ---`
- Summary at end with `process.exit(failed > 0 ? 1 : 0)`

Imports:
```javascript
import { tmpdir } from 'node:os';
import { mkdir, rm, writeFile, readFile } from 'node:fs/promises';
import path from 'node:path';
import assert from 'node:assert/strict';

import { parseMustHaves, extractTestableDeliveries, checkArtifactExists, checkArtifactSubstantive, buildUATContent, buildVerificationContent } from '../src/verify-work.js';
import { buildDebugFileContent, parseDebugFile } from '../src/debug-phase.js';
import { compareVersions, getInstalledVersion } from '../src/upstream-sync.js';
```

Note: Do NOT test `checkArtifactWired` (requires real project directory traversal), `updateDebugFile` (requires real file with specific format, fragile), `getActiveDebugSessions` (requires .planning/debug/ with real files), or `checkUpstreamVersion` (requires network/npm access). Test the pure functions and simple I/O functions.

Test categories (targeting ~15 tests):

**--- Must-Haves Parser tests ---**

Test 1: `parseMustHaves extracts truths from frontmatter`
- Provide PLAN.md content with must_haves section containing 3 truths
- Assert truths array has length 3 and contains expected text

Test 2: `parseMustHaves extracts artifacts from frontmatter`
- Provide content with artifacts section containing path, provides, exports, min_lines
- Assert artifacts array has length 1 with correct fields

Test 3: `parseMustHaves extracts key_links from frontmatter`
- Provide content with key_links section containing from, to, via, pattern
- Assert key_links array has correct structure

Test 4: `parseMustHaves returns null for content without must_haves`
- Provide content with frontmatter but no must_haves section
- Assert returns null

Test 5: `parseMustHaves handles real PLAN.md format`
- Read an actual PLAN.md from `.planning/phases/07-execution-workflow/07-01-PLAN.md` (use test fixture that mirrors this format)
- Create a temp file with realistic frontmatter matching the existing plan format
- Assert all three sections parsed correctly

**--- Artifact Checking tests ---**

Test 6: `checkArtifactExists returns true for existing file`
- Create a temp file
- Assert data.exists === true

Test 7: `checkArtifactExists returns false for non-existent file`
- Assert data.exists === false for a path that doesn't exist

Test 8: `checkArtifactSubstantive detects substantive files`
- Create a temp file with 20+ lines, exports, and no stub patterns
- Assert data.status === 'SUBSTANTIVE'

Test 9: `checkArtifactSubstantive detects stubs`
- Create a temp file with 3 lines and `// TODO: implement` content
- Assert data.status === 'STUB'

Test 10: `checkArtifactSubstantive detects missing exports`
- Create a temp file with enough lines but missing expected exports
- Assert data.status === 'PARTIAL' and missingExports is populated

**--- Debug File tests ---**

Test 11: `buildDebugFileContent generates valid debug file`
- Call with test data
- Assert content has frontmatter, all 5 sections (Current Focus, Symptoms, Eliminated, Evidence, Resolution)

Test 12: `parseDebugFile roundtrips with buildDebugFileContent`
- Build content, then parse it
- Assert parsed data matches input: status, trigger, slug
- Assert parsed sections exist (currentFocus, symptoms, etc.)

**--- UAT and Verification Content tests ---**

Test 13: `buildUATContent generates valid UAT file`
- Call with test data including 2 tests (1 pass, 1 fail)
- Assert has frontmatter with correct counts (passed: 1, failed: 1)
- Assert has test result sections

Test 14: `buildVerificationContent generates valid verification file`
- Call with test data including plan results
- Assert has frontmatter with status
- Assert has Summary section with pass/fail counts

**--- Version Comparison tests ---**

Test 15: `compareVersions correctly compares semver strings`
- Assert compareVersions('1.0.0', '1.1.0') returns { needsUpdate: true, comparison: 'behind' }
- Assert compareVersions('2.0.0', '1.0.0') returns { needsUpdate: false, comparison: 'ahead' }
- Assert compareVersions('1.0.0', '1.0.0') returns { needsUpdate: false, comparison: 'up-to-date' }

Test 16: `getInstalledVersion reads local package.json`
- Call getInstalledVersion('.') against the real project root
- Assert success: true and data.version matches a semver pattern
  </action>
  <verify>
Run: `node scripts/test-verify-work.js` -- should print all tests passing (16/16) and exit with code 0.
Verify workflow: `head -5 workflows/gsd/gsd-sync-upstream.md` should show YAML frontmatter.
  </verify>
  <done>
Workflow file exists at `workflows/gsd/gsd-sync-upstream.md` with version checking and update guidance. Integration test passes 16/16 tests covering: must-haves parsing (truths, artifacts, key_links, null case, real format), artifact checking (exists, substantive, stubs, missing exports), debug file roundtrip (build + parse), UAT/verification content generation, version comparison (behind, ahead, up-to-date), and installed version reading.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test:verify-work script to package.json</name>
  <files>package.json</files>
  <action>
Read the current `package.json` and add a new script entry:
```json
"test:verify-work": "node scripts/test-verify-work.js"
```

Add it after the existing `test:state` entry to maintain alphabetical ordering within the scripts section. The scripts section should look like:
```json
"scripts": {
  "test:agents": "node scripts/test-agent-infra.js",
  "test:execute-phase": "node scripts/test-execute-phase.js",
  "test:map-codebase": "node scripts/test-map-codebase.js",
  "test:plan-phase": "node scripts/test-plan-phase.js",
  "test:project-init": "node scripts/test-project-init.js",
  "test:state": "node scripts/test-state.js",
  "test:verify-work": "node scripts/test-verify-work.js"
}
```

Do NOT modify any other fields in package.json.

After updating package.json, run the test to verify:
```bash
npm run test:verify-work
```
  </action>
  <verify>
Run: `npm run test:verify-work` -- should execute the test script and pass all tests.
Also verify: `node -e "import pkg from './package.json' with { type: 'json' }; console.log(pkg.default.scripts['test:verify-work'] ? 'PASS' : 'FAIL');"` -- should print PASS.
  </verify>
  <done>
`package.json` has `test:verify-work` script in alphabetical order. `npm run test:verify-work` executes successfully with all 16 tests passing.
  </done>
</task>

</tasks>

<verification>
1. `node -e "import { getInstalledVersion, compareVersions, checkUpstreamVersion } from './src/upstream-sync.js'; console.log('OK');"` imports cleanly
2. `compareVersions` correctly identifies behind/ahead/up-to-date
3. `getInstalledVersion` reads real package.json version
4. `workflows/gsd/gsd-sync-upstream.md` has 3 steps and behavioral guidelines
5. `node scripts/test-verify-work.js` passes all 16 tests (exit code 0)
6. `npm run test:verify-work` runs successfully
7. Tests cover: parseMustHaves (5 tests), artifact checks (3 tests), debug file roundtrip (2 tests), UAT/verification content (2 tests), version comparison (2 tests)
8. No test calls checkUpstreamVersion (requires network), checkArtifactWired (requires project traversal), updateDebugFile (fragile), or getActiveDebugSessions (requires .planning/debug/)
9. Tests use tmpdir isolation with cleanup in finally block
10. Test pattern matches existing test-execute-phase.js structure
</verification>

<success_criteria>
- `src/upstream-sync.js` exports 3 functions with correct signatures
- Pure function returns value directly; I/O functions use error-return pattern
- Workflow guides version checking and re-installation without auto-updating
- 16 integration tests passing in `scripts/test-verify-work.js`
- Tests catch key pitfalls: frontmatter parsing, artifact checking, debug roundtrip, content generation
- `package.json` has `test:verify-work` script entry in alphabetical order
- `npm run test:verify-work` exits cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/08-verification-polish/08-03-SUMMARY.md`
</output>
